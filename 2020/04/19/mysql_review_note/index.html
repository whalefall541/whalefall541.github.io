<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>mysql_review_note | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="– select prod_name from products;– select prod_id,prod_name,prod_price– from Products;– select * from Products;– select distinct vend_id from Products;– SELECT prod_name FROM Products LIMIT 5;– 返回表中第五">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql_review_note">
<meta property="og:url" content="http://yoursite.com/2020/04/19/mysql_review_note/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="– select prod_name from products;– select prod_id,prod_name,prod_price– from Products;– select * from Products;– select distinct vend_id from Products;– SELECT prod_name FROM Products LIMIT 5;– 返回表中第五">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-19T04:49:50.360Z">
<meta property="article:modified_time" content="2020-04-01T09:21:36.327Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-mysql_review_note" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/mysql_review_note/" class="article-date">
  <time datetime="2020-04-19T04:49:50.360Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      mysql_review_note
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>– select prod_name from products;<br>– select prod_id,prod_name,prod_price<br>– from Products;<br>– select * from Products;<br>– select distinct vend_id from Products;<br>– SELECT prod_name FROM Products LIMIT 5;<br>– 返回表中第五行起的五行数据limit 5 offset 5;<br>– 注意取第一行数据是从offset 0开始<br>– limit 1 offset 0<br>– MySQL和MariaDB支持简化写法limit offset,limitnum</p>
<h1 id="select-prod-name-from-Products-limit-0-1"><a href="#select-prod-name-from-Products-limit-0-1" class="headerlink" title="select prod_name from Products limit 0,1;"></a>select prod_name from Products limit 0,1;</h1><p>– Oracle中的写法<br>– SELECT prod_name<br>– FROM Products<br>– WHERE ROWNUM &lt;=5;<br>/<em>fds</em>/</p>
<p>– SELECT prod_id, prod_price, prod_name<br>– FROM Products order by prod_price,prod_name;</p>
<p>– SELECT prod_name, prod_price<br>– FROM Products<br>– WHERE prod_price = 3.49;</p>
<p>– 一般情况下 != 和&lt;&gt;可以互换<br>– SELECT vend_id, prod_name<br>– FROM Products<br>– WHERE vend_id &lt;&gt; ‘DLL01’;</p>
<p>– 判断空值null<br>– select cust_name from customers where cust_email is null;</p>
<p>– 注意运算优先级 最好加括号<br>– SELECT vend_id,prod_name, prod_price<br>– FROM Products<br>– WHERE vend_id = ‘DLL01’ OR vend_id = ‘BRS01’;</p>
<p>– SELECT prod_name, prod_price<br>– FROM Products<br>– WHERE (vend_id = ‘DLL01’ OR vend_id = ‘BRS01’)<br>– AND prod_price &gt;= 10;</p>
<p>– in 和 or 用来匹配值得关键字时，都能起到这种效果，那么用in有什么好处？<br>– 1.在很多合法选项时，in操作符的语法更清楚，更直观。<br>– 2.在与其他and 和 or操作符组合使用in时，求值顺序更容易管理。<br>– 3.in 操作符一般比一组or操作符执行得更快。<br>– 4.in 最大优点是可以包括其他select 语句，能够动态地建立where子句，进行复杂查询。</p>
<p>– SELECT prod_name, prod_price<br>– FROM Products<br>– WHERE vend_id IN ( ‘DLL01’, ‘BRS01’ )<br>– ORDER BY prod_name;</p>
<p>– SELECT vend_id,prod_name, prod_price<br>– FROM Products<br>– WHERE vend_id = ‘DLL01’ OR vend_id = ‘BRS01’;</p>
<p>– NOT 用在where子句中用来否定其后条件的关键字<br>– select prod_name<br>– from Products<br>– where not vend_id = ‘DLL01’ ORDER BY prod_name;</p>
<p>– SELECT prod_name<br>– FROM Products<br>– WHERE vend_id &lt;&gt; ‘DLL01’<br>– ORDER BY prod_name;</p>
<p>–  not 和 &lt;&gt;都能达到取非得操作，使用not有什么好处呢？<br>– 在与in操作符联合使用时，not可以非常简单地找出与条件列表不匹配的行</p>
<p>– 搜索以词Fish开头的产品<br>– %表示任何字符出现任意次数（包括0次）<br>– %无法匹配null值<br>– SELECT prod_id, prod_name FROM Products<br>– WHERE prod_name LIKE ‘Fish%’;</p>
<p>– SELECT prod_id, prod_name<br>– FROM Products<br>– WHERE prod_name LIKE ‘%bean bag%’;</p>
<p>– SELECT prod_name<br>– FROM Products<br>– WHERE prod_name LIKE ‘F%y’;</p>
<p>– SELECT prod_id, prod_name<br>– FROM Products<br>– WHERE prod_name LIKE ‘__ inch teddy bear’;</p>
<p>– SELECT Concat(vend_name, ‘ (‘, vend_country, ‘)’) AS vend_title<br>– FROM Vendors<br>– ORDER BY vend_name;</p>
<p>– SELECT now();<br>– SELECT TRIM(‘ hello ‘);<br>– SubString  Convert  CURRENT_DATE<br>– select CURRENT_DATE</p>
<p>– SELECT vend_name, UPPER(vend_name) AS vend_name_upcase<br>– FROM Vendors<br>– ORDER BY vend_name</p>
<p>– 常见函数<br>– left right        返回字符串左(右)边的字符<br>– length             返回字符串的长度<br>– ltrim rtrim     去掉字符串左(右)边的字符<br>– soundex            返回字符串的soundex值<br>– upper lower     将字符串转化为大(小)写</p>
<p>– soundex 是一种将任何文本串转为描述其语音表示的字母数字模式的算法。soundex考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较。<br>– SELECT cust_name, cust_contact<br>– FROM Customers<br>– WHERE SOUNDEX(cust_contact) = SOUNDEX(‘Michael Green’);</p>
<p>– Oracle中日期处理函数没有datepart<br>– to_char()函数用来提取日期的成分，to_number()用来将提取出的成分转化为数值，以便能与2012进行比较。<br>– SELECT order_num<br>– FROM Orders<br>– WHERE to_number(to_char(order_date, ‘YYYY’)) = 2012;</p>
<p>– SELECT order_num<br>– FROM Orders<br>– WHERE order_date BETWEEN to_date(‘01-01-2012’)<br>– AND to_date(‘12-31-2012’);</p>
<p>– mysql 使用Year()函数提取年<br>– SELECT order_num<br>– FROM Orders<br>– WHERE YEAR(order_date) = 2012;</p>
<p>– 常见时间函数<br>– 1. CURDATE()以‘YYYY-MM-DD’形式或值的形式返回当前时间<br>– SELECT CURDATE();</p>
<p>– 2.DATE(expr)  获取指定时间的年月日部分<br>– SELECT DATE(‘2003-12-31 01:02:03’);</p>
<p>– 3.DATEDIFF(expr1,expr2) 返回时间值expr1 - 时间值expr2之间相差的天数。<br>– SELECT DATEDIFF(‘2007-12-31 23:59:59’,’2007-12-30’) as diff;</p>
<p>– 4.DATE_FORMAT(date,format) date根据format的格式转换成字符串<br>– SELECT DATE_FORMAT(‘2009-10-04 22:23:00’, ‘%W %M %Y’);</p>
<p>– 5.DAYNAME(date) 返回指定日期是周几<br>– select dayname(‘2020-03-05’);</p>
<p>– 6. DAYOFMONTH(date)  DAYOFWEEK(date)<br>– DAYOFYEAR(date) LAST_DAY(date) FROM_UNIXTIME(unix_timestamp) NOW()</p>
<p>– 7.PERIOD_ADD(P,N) 将N个月添加到P中<br>– SELECT PERIOD_ADD(200801,2);</p>
<p>– 8.区分sysdate 和 now函数<br>– select SYSDATE();<br>– select NOW();<br>– NOW()取的是语句开始执行的时间，SYSDATE()取的是动态的实时时间。<br>– 因为NOW()取自mysql的一个变量”TIMESTAMP”，而这个变量在语句开始执行的时候就设定好了，因此在整个语句执行过程中都不会变化。</p>
<p>– 9.UNIX_TIMESTAMP([date]) 如果不带参数，则返回一个unix时间戳；如果带date格式，则返回与’1970-01-01 00:00:00’UTC 相差的秒数形式的参数值<br>– SELECT UNIX_TIMESTAMP();<br>– SELECT UNIX_TIMESTAMP(‘2020-03-04 11:51:41’);</p>
<p>– 10 CONVERT_TZ(dt,from_tz,to_tz)<br>– SELECT CONVERT_TZ(‘2004-01-01 12:00:00’,’+00:00’,’+10:00’);</p>
<p>– 数值处理函数<br>– ABS(X) COS(X) SIN(X) TAN(X) EXP(X) 返回指数值 PI()返回圆周率 SQRT(X) 返回一个数的平方根 </p>
<p>– 聚集函数<br>– AVG() 函数忽略列值为NULL的行<br>– SELECT AVG(prod_price) AS avg_price<br>– FROM Products<br>– WHERE vend_id = ‘DLL01’;</p>
<p>– count(*)对表中的行的数目进行技术，不管表列中的是空指，还是非空值<br>– COUNT(COLUMN)</p>
<p>– SELECT COUNT(*) AS num_cust<br>– FROM Customers;<br>– SELECT COUNT(cust_email) AS num_cust<br>– FROM Customers;</p>
<p>– 在用于文本数据时，MAX()返回按该列排序后的最后一行数据，MAX()函数忽略列值为NULL的行</p>
<p>– SELECT AVG(DISTINCT prod_price) AS avg_price<br>– FROM Products<br>– WHERE vend_id = ‘DLL01’;</p>
<p>– 分组 GROUP BY<br>– SELECT vend_id, COUNT(*) AS num_prods<br>– FROM Products<br>– GROUP BY vend_id;</p>
<p>– 注意 GROUP BY 子句中出现的每一列必须是检索列或者有效的表达式(但不能是聚集函数)，如果SELECT中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式，不能使用别名。</p>
<p>– where 可以用来过滤行，而having 可以用来过滤组<br>– SELECT cust_id, COUNT(<em>) AS orders<br>– FROM Orders<br>– GROUP BY cust_id<br>– HAVING COUNT(</em>) &gt;= 2;</p>
<p>– SELECT vend_id, COUNT(<em>) AS num_prods<br>– FROM Products<br>– WHERE prod_price &gt;= 4<br>– GROUP BY vend_id<br>– HAVING COUNT(</em>) &gt;= 2;</p>
<p>– 分组与排序<br>– GROUP BY 和 ORDER BY</p>
<p>– SELECT order_num, COUNT(<em>) AS items<br>– FROM OrderItems<br>– GROUP BY order_num<br>– HAVING COUNT(</em>) &gt;= 3<br>– ORDER BY items, order_num;</p>
<p>– SELECT cust_name, cust_contact<br>– FROM Customers<br>– WHERE cust_id IN (SELECT cust_id<br>– FROM Orders<br>– WHERE order_num IN (SELECT order_num<br>– FROM OrderItems<br>– WHERE prod_id = ‘RGAN01’));</p>
<p>– SELECT cust_name,<br>– cust_state,<br>– (SELECT COUNT(*)<br>– FROM Orders<br>– WHERE Orders.cust_id = Customers.cust_id) AS orders<br>– FROM Customers<br>– ORDER BY cust_name;</p>
<p>– SELECT vend_name, prod_name, prod_price<br>– FROM Vendors, Products<br>– WHERE Vendors.vend_id = Products.vend_id;</p>
<p>– 内连接查询<br>– SELECT vend_name, prod_name, prod_price<br>– FROM Vendors INNER JOIN Products<br>– ON Vendors.vend_id = Products.vend_id;</p>
<p>– 多表关联查询<br>– SELECT prod_name, vend_name, prod_price, quantity<br>– FROM OrderItems, Products, Vendors<br>– WHERE Products.vend_id = Vendors.vend_id<br>– AND OrderItems.prod_id = Products.prod_id<br>– AND order_num = 20007;</p>
<p>– SELECT cust_name, cust_contact<br>– FROM Customers, Orders, OrderItems<br>– WHERE Customers.cust_id = Orders.cust_id<br>– AND OrderItems.order_num = Orders.order_num<br>– AND prod_id = ‘RGAN01’;</p>
<p>– 自联结<br>– 自联结通常作为外部语句，用来代替从相同表中检索的使用子查询的语句<br>– SELECT c1.cust_id, c1.cust_name, c1.cust_contact<br>– FROM Customers AS c1, Customers AS c2<br>– WHERE c1.cust_name = c2.cust_name<br>– AND c2.cust_contact = ‘Jim Jones’;</p>
<p>– 子查询<br>– SELECT cust_id, cust_name, cust_contact<br>– FROM Customers<br>– WHERE cust_name = (SELECT cust_name<br>– FROM Customers<br>– WHERE cust_contact = ‘Jim Jones’);</p>
<p>– 自然联接 使用SELECT tablename.* 使每一列只返回一次<br>– SELECT C.*, O.order_num, O.order_date,<br>– OI.prod_id, OI.quantity, OI.item_price<br>– FROM Customers AS C, Orders AS O, OrderItems AS OI<br>– WHERE C.cust_id = O.cust_id<br>– AND OI.order_num = O.order_num<br>– AND prod_id = ‘RGAN01’;</p>
<p>– 外联接<br>– SELECT Customers.cust_id, Orders.order_num<br>– FROM Customers LEFT OUTER JOIN Orders<br>– ON Customers.cust_id = Orders.cust_id;</p>
<p>– SELECT Customers.cust_id, Orders.order_num<br>– FROM Customers RIGHT OUTER JOIN Orders<br>– ON Orders.cust_id = Customers.cust_id;</p>
<p>– SELECT Customers.cust_id, Orders.order_num<br>– FROM Orders LEFT OUTER JOIN Customers<br>– ON Orders.cust_id = Customers.cust_id<br>– UNION<br>– SELECT Customers.cust_id, Orders.order_num<br>– FROM Orders RIGHT OUTER JOIN Customers<br>– ON Orders.cust_id = Customers.cust_id order by cust_id;</p>
<p>– 聚合函数 应用于联接中<br>– SELECT Customers.cust_id,<br>– COUNT(Orders.order_num) AS num_ord<br>– FROM Customers INNER JOIN Orders<br>– ON Customers.cust_id = Orders.cust_id<br>– GROUP BY Customers.cust_id;</p>
<p>– SELECT Customers.cust_id,<br>– COUNT(Orders.order_num) AS num_ord<br>– FROM Customers LEFT OUTER JOIN Orders<br>– ON Customers.cust_id = Orders.cust_id<br>– GROUP BY Customers.cust_id;</p>
<p>– SELECT cust_name, cust_contact, cust_email<br>– FROM Customers<br>– WHERE cust_state IN (‘IL’,’IN’,’MI’)<br>– OR cust_name = ‘Fun4All’;</p>
<p>– 使用UNION时默认回去重，如果想显式所有行，则使用UNION ALL<br>– SELECT cust_name, cust_contact, cust_email<br>– FROM Customers<br>– WHERE cust_state IN (‘IL’,’IN’,’MI’)<br>– UNION ALL<br>– SELECT cust_name, cust_contact, cust_email<br>– FROM Customers<br>– WHERE cust_name = ‘Fun4All’;</p>
<p>– SELECT cust_name, cust_contact, cust_email<br>– FROM Customers<br>– WHERE cust_state IN (‘IL’,’IN’,’MI’)<br>– UNION<br>– SELECT cust_name, cust_contact, cust_email<br>– FROM Customers<br>– WHERE cust_name = ‘Fun4All’<br>– ORDER BY cust_name, cust_contact;</p>
<p>– insert 语句<br>– INSERT INTO Customers(cust_id,<br>– cust_name,<br>– cust_address,<br>– cust_city,<br>– cust_state,<br>– cust_zip,<br>– cust_country,<br>– cust_contact,<br>– cust_email)<br>– VALUES(‘1000000006’,<br>– ‘Toy Land’,<br>– ‘123 Any Street’,<br>– ‘New York’,<br>– ‘NY’,<br>– ‘11111’,<br>– ‘USA’,<br>– NULL,<br>– NULL);</p>
<p>– INSERT INTO Customers(cust_id,<br>– cust_contact,<br>– cust_email,<br>– cust_name,<br>– cust_address,<br>– cust_city,<br>– cust_state,<br>– cust_zip,<br>– cust_country)<br>– SELECT cust_id,<br>– cust_contact,<br>– cust_email,<br>– cust_name,<br>– cust_address,<br>– cust_city,<br>– cust_state,<br>– cust_zip,<br>– cust_country<br>– FROM CustNew;</p>
<p>– ISNERT SELECT导出数据， SELECT INTO导入数据<br>– SELECT *<br>– INTO CustCopy<br>– FROM Customers;</p>
<p>– CREATE TABLE CustCopy AS<br>– SELECT * FROM Customers;</p>
<p>– DELETE删除整行 甚至是删除表中所有的行，删除列使用update<br>– 删除表中的内容使用 TRUNCATE TABLE 语句更快(因为不记录数据的变动)</p>
<p>– 更改表结构<br>– ALTER TABLE Vendors<br>– ADD vend_phone CHAR(20);</p>
<p>– ALTER TABLE Vendors<br>– DROP COLUMN vend_phone;</p>
<p>– DROP TABLE CustCopy;</p>
<p>– 创建视图<br>– CREATE VIEW ProductCustomers AS<br>– SELECT cust_name, cust_contact, prod_id<br>– FROM Customers, Orders, OrderItems<br>– WHERE Customers.cust_id = Orders.cust_id<br>– AND OrderItems.order_num = Orders.order_num;</p>
<p>– select cust_name,cust_contact<br>–     from ProductCustomers<br>–         where prod_id = ‘RGAN01’;</p>
<p>– CREATE VIEW VendorLocations AS<br>– SELECT Concat(vend_name, ‘ (‘, vend_country, ‘)’)<br>– AS vend_title<br>– FROM Vendors;</p>
<p>– SELECT *<br>– FROM VendorLocations;</p>
<p>– CREATE VIEW CustomerEMailList AS<br>– SELECT cust_id, cust_name, cust_email<br>– FROM Customers<br>– WHERE cust_email IS NOT NULL;<br>–<br>– SELECT *<br>– FROM CustomerEMailList;</p>
<p>– CREATE VIEW OrderItemsExpanded AS<br>– SELECT order_num,<br>– prod_id,<br>– quantity,<br>– item_price,<br>– quantity*item_price AS expanded_price<br>– FROM OrderItems;<br>–<br>– SELECT *<br>– FROM OrderItemsExpanded<br>– WHERE order_num = 20008;</p>
<p>– 视图为虚拟表，它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据。</p>
<p>– 存储过程 为了以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。<br>– SAVEPOINT delete1;<br>– ROLLBACK TO delete1;</p>
<p>– mysql里得写在一个存储过程里，而且mysql的声明都要一起写在最前面<br>– DECLARE CustCursor CURSOR<br>– FOR<br>– SELECT * FROM Customers<br>– WHERE cust_email IS NULL;<br>–<br>– OPEN CURSOR CustCursor</p>
<p>– 定义外键<br>– CREATE TABLE Orders<br>– (<br>– order_num INTEGER NOT NULL PRIMARY KEY,<br>– order_date DATETIME NOT NULL,<br>– cust_id CHAR(10) NOT NULL REFERENCES<br>–     Customers(cust_id)<br>– );</p>
<p>– ALTER TABLE Orders<br>– ADD CONSTRAINT<br>– FOREIGN KEY (cust_id) REFERENCES Customers (cust_id)</p>
<p>– 级联删除：在从一个表中删除行时，除删除所有相关的数据。<br>– 唯一约束用来保证一列中的数据是唯一的。它们类似与主键但是存在区别：<br>    – 表可以包含多个唯一约束，但每个表只允许一个主键<br>    – 唯一约束列可以包含NULL值。<br>    – 唯一约束列可以修改或更新。<br>    – 唯一约束列的值可重复使用。<br>    – 与主键不一样，唯一约束不能用来定义外键。</p>
<pre><code>-- 检查约束
-- 检查数量必须&gt;0才能插入行</code></pre><p>– CREATE TABLE OrderItems<br>– (<br>– order_num INTEGER NOT NULL,<br>– order_item INTEGER NOT NULL,<br>– prod_id CHAR(10) NOT NULL,<br>– quantity INTEGER NOT NULL CHECK (quantity &gt; 0),<br>– item_price MONEY NOT NULL<br>– );</p>
<p>– 索引<br>    – 索引改善检索操作性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态的更新索引。<br>    – 索引数据可能要占用大量的存储空间。<br>    – 并非所有的数据都适合做索引。取值不多的数据（如州）不如具有更多可能值得数据（如姓或名），能通过索引得到那么多的好处。<br>    – 索引用于数据过滤和数据排序。如果经常以某种特定的顺序排序数据，则该数据可能更适合做索引。<br>    – 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。</p>
<p>– 创建索引<br>– CREATE INDEX prod_name_ind<br>– ON Products (prod_name);</p>
<p>– 触发器<br>– 触发器是特殊的储存过程，它在特殊的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联。与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个表相关联。</p>
<p>– 窗口函数<br>函数名 OVER 子句<br>如果不为空，则支持以下4中语法来设置窗口。<br>①window_name：给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读；<br>②PARTITION BY 子句：窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行；<br>③ORDER BY子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号；<br>④FRAME子句：FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。</p>
<p>①序号函数 row_number() rank() dense_rank()<br>ROW_NUMBER()：顺序排序——1、2、3<br>RANK()：并列排序，跳过重复序号——1、1、3<br>DENSE_RANK()：并列排序，不跳过重复序号——1、1、2</p>
<p>mysql&gt; SELECT *<br>    -&gt; FROM(<br>    -&gt;     SELECT stu_id,<br>    -&gt;     ROW_NUMBER() OVER (PARTITION BY stu_id ORDER BY score DESC) AS score_order,<br>    -&gt;     lesson_id, score<br>    -&gt;     FROM t_score) t<br>    -&gt; WHERE score_order &lt;= 3<br>    -&gt; ;<br>+——–+————-+———–+——-+<br>| stu_id | score_order | lesson_id | score |<br>+——–+————-+———–+——-+<br>|      1 |           1 | L005      |    98 |<br>|      1 |           2 | L001      |    98 |<br>|      1 |           3 | L004      |    88 |<br>|      2 |           1 | L002      |    90 |<br>|      2 |           2 | L003      |    86 |<br>|      2 |           3 | L001      |    84 |<br>|      3 |           1 | L001      |   100 |<br>|      3 |           2 | L002      |    91 |<br>|      3 |           3 | L003      |    85 |<br>|      4 |           1 | L001      |    99 |<br>|      4 |           2 | L005      |    98 |<br>|      4 |           3 | L002      |    88 |<br>+——–+————-+———–+——-+</p>
<p>②分布函数 PERCENT_RANK()、CUME_DIST()<br>PERCENT_RANK()<br>用途：每行按照公式(rank-1) / (rows-1)进行计算。其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数</p>
<p>用途：分组内小于、等于当前rank值的行数 / 分组内总行数<br>应用场景：查询小于等于当前成绩（score）的比例<br>mysql&gt; SELECT stu_id, lesson_id, score,<br>    -&gt; CUME_DIST() OVER (ORDER BY score) AS cd1,<br>    -&gt; CUME_DIST() OVER (PARTITION BY lesson_id ORDER BY score) AS cd2<br>    -&gt; FROM t_score<br>    -&gt; WHERE lesson_id IN (‘L001’,’L002’)<br>    -&gt; ;<br>+——–+———–+——-+——-+——+<br>| stu_id | lesson_id | score | cd1   | cd2  |<br>+——–+———–+——-+——-+——+<br>|      2 | L001      |    84 | 0.125 | 0.25 |<br>|      1 | L001      |    98 |  0.75 |  0.5 |<br>|      4 | L001      |    99 | 0.875 | 0.75 |<br>|      3 | L001      |   100 |     1 |    1 |<br>|      1 | L002      |    86 |  0.25 | 0.25 |<br>|      4 | L002      |    88 | 0.375 |  0.5 |<br>|      2 | L002      |    90 |   0.5 | 0.75 |<br>|      3 | L002      |    91 | 0.625 |    1 |<br>+——–+———–+——-+——-+——+</p>
<p>③前后函数：LAG(expr,n)、LEAD(expr,n)<br>用途：返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值<br>应用场景：查询前1名同学的成绩和当前同学成绩的差值</p>
<p>mysql&gt; SELECT stu_id, lesson_id, score, pre_score,<br>    -&gt; score-pre_score AS diff<br>    -&gt; FROM(<br>    -&gt;     SELECT stu_id, lesson_id, score,<br>    -&gt;     LAG(score,1) OVER w AS pre_score<br>    -&gt;     FROM t_score<br>    -&gt;     WHERE lesson_id IN (‘L001’,’L002’)<br>    -&gt;     WINDOW w AS (PARTITION BY lesson_id ORDER BY score)) t<br>    -&gt; ;<br>+——–+———–+——-+———–+——+<br>| stu_id | lesson_id | score | pre_score | diff |<br>+——–+———–+——-+———–+——+<br>|      2 | L001      |    84 |      NULL | NULL |<br>|      1 | L001      |    98 |        84 |   14 |<br>|      4 | L001      |    99 |        98 |    1 |<br>|      3 | L001      |   100 |        99 |    1 |<br>|      1 | L002      |    86 |      NULL | NULL |<br>|      4 | L002      |    88 |        86 |    2 |<br>|      2 | L002      |    90 |        88 |    2 |<br>|      3 | L002      |    91 |        90 |    1 |<br>+——–+———–+——-+———–+——+</p>
<p>④头尾函数：FIRST_VALUE(expr)、LAST_VALUE(expr)<br>用途：返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值<br>应用场景：截止到当前成绩，按照日期排序查询第1个和最后1个同学的分数<br>添加新列：mysql&gt; ALTER TABLE t_score ADD create_time DATE;</p>
<p>mysql&gt; SELECT stu_id, lesson_id, score, create_time,<br>    -&gt; FIRST_VALUE(score) OVER w AS first_score,<br>    -&gt; LAST_VALUE(score) OVER w AS last_score<br>    -&gt; FROM t_score<br>    -&gt; WHERE lesson_id IN (‘L001’,’L002’)<br>    -&gt; WINDOW w AS (PARTITION BY lesson_id ORDER BY create_time)<br>    -&gt; ;<br>+——–+———–+——-+————-+————-+————+<br>| stu_id | lesson_id | score | create_time | first_score | last_score |<br>+——–+———–+——-+————-+————-+————+<br>|      3 | L001      |   100 | 2018-08-07  |         100 |        100 |<br>|      1 | L001      |    98 | 2018-08-08  |         100 |         98 |<br>|      2 | L001      |    84 | 2018-08-09  |         100 |         99 |<br>|      4 | L001      |    99 | 2018-08-09  |         100 |         99 |<br>|      3 | L002      |    91 | 2018-08-07  |          91 |         91 |<br>|      1 | L002      |    86 | 2018-08-08  |          91 |         86 |<br>|      2 | L002      |    90 | 2018-08-09  |          91 |         90 |<br>|      4 | L002      |    88 | 2018-08-10  |          91 |         88 |<br>+——–+———–+——-+————-+————-+————+</p>
<p>⑤其它函数：NTH_VALUE(expr, n)、NTILE(n)<br>NTH_VALUE(expr,n)<br>用途：返回窗口中第n个expr的值。expr可以是表达式，也可以是列名<br>应用场景：截止到当前成绩，显示每个同学的成绩中排名第2和第3的成绩的分数<br>mysql&gt; SELECT stu_id, lesson_id, score,<br>    -&gt; NTH_VALUE(score,2) OVER w AS second_score,<br>    -&gt; NTH_VALUE(score,3) OVER w AS third_score<br>    -&gt; FROM t_score<br>    -&gt; WHERE stu_id IN (1,2)<br>    -&gt; WINDOW w AS (PARTITION BY stu_id ORDER BY score)<br>    -&gt; ;<br>+——–+———–+——-+————–+————-+<br>| stu_id | lesson_id | score | second_score | third_score |<br>+——–+———–+——-+————–+————-+<br>|      1 | L003      |    79 |         NULL |        NULL |<br>|      1 | L002      |    86 |           86 |        NULL |<br>|      1 | L004      |    88 |           86 |          88 |<br>|      1 | L001      |    98 |           86 |          88 |<br>|      1 | L005      |    98 |           86 |          88 |<br>|      2 | L004      |    75 |         NULL |        NULL |<br>|      2 | L005      |    77 |           77 |        NULL |<br>|      2 | L001      |    84 |           77 |          84 |<br>|      2 | L003      |    86 |           77 |          84 |<br>|      2 | L002      |    90 |           77 |          84 |<br>+——–+———–+——-+————–+————-+</p>
<p>NTILE(n)<br>用途：将分区中的有序数据分为n个等级，记录等级数<br>应用场景：将每门课程按照成绩分成3组<br>mysql&gt; SELECT<br>    -&gt; NTILE(3) OVER w AS nf,<br>    -&gt; stu_id, lesson_id, score<br>    -&gt; FROM t_score<br>    -&gt; WHERE lesson_id IN (‘L001’,’L002’)<br>    -&gt; WINDOW w AS (PARTITION BY lesson_id ORDER BY score)<br>    -&gt; ;<br>+——+——–+———–+——-+<br>| nf   | stu_id | lesson_id | score |<br>+——+——–+———–+——-+<br>|    1 |      2 | L001      |    84 |<br>|    1 |      1 | L001      |    98 |<br>|    2 |      4 | L001      |    99 |<br>|    3 |      3 | L001      |   100 |<br>|    1 |      1 | L002      |    86 |<br>|    1 |      4 | L002      |    88 |<br>|    2 |      2 | L002      |    90 |<br>|    3 |      3 | L002      |    91 |<br>+——+——–+———–+——-+<br>NTILE(n)函数在数据分析中应用较多，比如由于数据量大，需要将数据平均分配到n个并行的进程分别计算，此时就可以用NTILE(n)对数据进行分组（由于记录数不一定被n整除，所以数据不一定完全平均），然后将不同桶号的数据再分配。</p>
<p>⑥聚合函数作为窗口函数：<br>用途：在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值<br>应用场景：截止到当前时间，查询stu_id=1的学生的累计分数、分数最高的科目、分数最低的科目</p>
<p>mysql&gt; SELECT stu_id, lesson_id, score, create_time,<br>    -&gt; SUM(score) OVER w AS score_sum,<br>    -&gt; MAX(score) OVER w AS score_max,<br>    -&gt; MIN(score) OVER w AS score_min<br>    -&gt; FROM t_score<br>    -&gt; WHERE stu_id = 1<br>    -&gt; WINDOW w AS (PARTITION BY stu_id ORDER BY create_time)<br>    -&gt; ;<br>+——–+———–+——-+————-+———–+———–+———–+</p>
<p>| stu_id | lesson_id | score | create_time | score_sum | score_max | score_min |</p>
<p>+——–+———–+——-+————-+———–+———–+———–+</p>
<p>|      1 | L001      |    98 | 2018-08-08  |       184 |        98 |        86 |</p>
<p>|      1 | L002      |    86 | 2018-08-08  |       184 |        98 |        86 |</p>
<p>|      1 | L003      |    79 | 2018-08-09  |       263 |        98 |        79 |</p>
<p>|      1 | L004      |    88 | 2018-08-10  |       449 |        98 |        79 |</p>
<p>|      1 | L005      |    98 | 2018-08-10  |       449 |        98 |        79 |</p>
<p>+——–+———–+——-+————-+———–+———–+———–+</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/mysql_review_note/" data-id="ckautpoj6000794rhg5sa33ug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/19/sql_optimize/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          sql_optimize
        
      </div>
    </a>
  
  
    <a href="/2020/04/18/summary%20for%20bigdata/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">summary for bigdata</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/31/1/">1</a>
          </li>
        
          <li>
            <a href="/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E6%80%BB%E7%BB%93/">并发编程艺术总结</a>
          </li>
        
          <li>
            <a href="/2020/05/14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">git常用命令</a>
          </li>
        
          <li>
            <a href="/2020/05/09/thread/">thread</a>
          </li>
        
          <li>
            <a href="/2020/05/09/netcompile/">netcompile</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>