<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JAVA | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java内存常识 1.计数器、虚拟机栈、本地方法栈数据不共享；堆、方法区中数据共享。 2.常量池：用来存放字面量和符号引用，是方法区的一部分。运行时，也可以使用String.intern()方法将新的常量加入其中。 3.sun hotspot 把本地方法栈和虚拟机栈合二为一 4.jdk7时字符串常量从永久代移除，jdk8 永久代PermGen被MetaSpace取代，使用native内存，由虚拟机">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA">
<meta property="og:url" content="http://yoursite.com/2020/04/19/JAVA/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="java内存常识 1.计数器、虚拟机栈、本地方法栈数据不共享；堆、方法区中数据共享。 2.常量池：用来存放字面量和符号引用，是方法区的一部分。运行时，也可以使用String.intern()方法将新的常量加入其中。 3.sun hotspot 把本地方法栈和虚拟机栈合二为一 4.jdk7时字符串常量从永久代移除，jdk8 永久代PermGen被MetaSpace取代，使用native内存，由虚拟机">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="f:%5Cblog%5Csource_posts%5CJAVA%5Cgarbage-collection-outline.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/CMS.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/G1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/exception.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/Collection.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/640.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/641.jpg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/f58f6ad856c6802b636d20d8f5ba2c3e.jpeg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/640.webp">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/641.webp">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/425.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/20200412234359327.png">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/springboot.webp">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/mvgyfyd1cq.jpeg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/w0719vs47g.jpeg">
<meta property="og:image" content="http://yoursite.com/2020/04/19/JAVA/11464886-82267cb5926d26fb.webp">
<meta property="article:published_time" content="2020-04-19T09:58:10.440Z">
<meta property="article:modified_time" content="2020-05-31T12:29:35.379Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="f:%5Cblog%5Csource_posts%5CJAVA%5Cgarbage-collection-outline.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/JAVA/" class="article-date">
  <time datetime="2020-04-19T09:58:10.440Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JAVA
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java内存常识"><a href="#java内存常识" class="headerlink" title="java内存常识"></a>java内存常识</h1><ul>
<li>1.计数器、虚拟机栈、本地方法栈数据不共享；堆、方法区中数据共享。</li>
<li>2.常量池：用来存放字面量和符号引用，是方法区的一部分。运行时，也可以使用String.intern()方法将新的常量加入其中。</li>
<li>3.sun hotspot 把本地方法栈和虚拟机栈合二为一</li>
<li>4.jdk7时字符串常量从永久代移除，jdk8 永久代PermGen被MetaSpace取代，使用native内存，由虚拟机负责管理。</li>
</ul>
<h1 id="垃圾回收以及算法"><a href="#垃圾回收以及算法" class="headerlink" title="垃圾回收以及算法"></a>垃圾回收以及算法</h1><p>OMM：调大内存参数，或者</p>
<p>引用计数法：当有一个地方使用计数值+1，失效时-1，为0时是不可再被引用的对象<br>缺点：循环引用时，某些对象将无法被回收掉</p>
<p>可达性分析算法：通过一系列的称为GCROOTS的对象作为起点，往下搜索（路径为引用链），当对象不与GC任何引用链相连时，则这些对象是不可达的。<br>GCROOTS对象包括：</p>
<ul>
<li>1.虚拟机栈中引用的对象</li>
<li>2.方法区中静态属性或者常量引用的对象</li>
<li>3.本地方法引用的对象</li>
</ul>
<p>垃圾收集算法：</p>
<ul>
<li>1.标记清除（造成碎皮空间）</li>
<li>2.复制算法 (内存使用率50%)</li>
<li>3.标记整理 (比标记清除多一步，将存活对象移动到一端，清除其他的对象)    </li>
<li>4.分代算法 (新生代：复制算法 老年代：标记清除或者标记整理)</li>
</ul>
<p>垃圾收集器：</p>
<p><img src="F:%5Cblog%5Csource_posts%5CJAVA%5Cgarbage-collection-outline.jpg" alt=""></p>
<ul>
<li>ParNew(多线程 高吞吐)</li>
<li>CMS(初始标记，并发标记（时间长），重新标记，并发清除（时间长）低延迟)<br><img src="./CMS.jpg" alt="CMS垃圾收集过程图"><ul>
<li>G1(将整个堆划分为一个个小块，1-32M,RememberSet指向块的内存地址) 调整小 -XX:InitiatingHeapOccupancyPercent=45% 增多Minor GC频率，减少Full GC频率<br><img src="./G1.jpg" alt="G1垃圾收集过程图"></li>
</ul>
</li>
</ul>
<p>人员分组：3后台 1前台 1测试  30人左右 18 7 64 运维</p>
<h1 id="JDK和JRE有什么区别？"><a href="#JDK和JRE有什么区别？" class="headerlink" title="JDK和JRE有什么区别？"></a>JDK和JRE有什么区别？</h1><ul>
<li>JDK:java开发工具包，提供了java开发环境和运行环境</li>
<li>JRE:java运行环境<br>具体来说JDK包含了JRE，同时还包含了编译器，程序调试和分析工具</li>
</ul>
<h1 id="和-equals区别"><a href="#和-equals区别" class="headerlink" title="== 和 equals区别"></a>== 和 equals区别</h1><p>==</p>
<ul>
<li>基本类型：比较的是值是否相同</li>
<li>引用类型：比较的是引用是否相同</li>
</ul>
<p>equals</p>
<ul>
<li><p>本质上是==，比较引用，只不过String和Integer等重写了equals方法，把它变成了值比较</p>
</li>
<li><p>基本类型八种：byte short int long float double boolean</p>
</li>
<li><p>复杂数据类型：== 比较地址，重写之后equals 比较内容相同时也为true</p>
</li>
</ul>
<h1 id="两个对象的HashCode-相同，则equals也一定为true，对吗？"><a href="#两个对象的HashCode-相同，则equals也一定为true，对吗？" class="headerlink" title="两个对象的HashCode()相同，则equals也一定为true，对吗？"></a>两个对象的HashCode()相同，则equals也一定为true，对吗？</h1><ul>
<li>不对。”通话”和”重地”的HashCode相同，然而equals为false</li>
</ul>
<h1 id="final-在java中作用？"><a href="#final-在java中作用？" class="headerlink" title="final 在java中作用？"></a>final 在java中作用？</h1><p>修饰最终类、最终方法、常量(必须初始化，初始化后值不能被修改)</p>
<h1 id="java中操作字符串的类有哪些？各有什么区别？"><a href="#java中操作字符串的类有哪些？各有什么区别？" class="headerlink" title="java中操作字符串的类有哪些？各有什么区别？"></a>java中操作字符串的类有哪些？各有什么区别？</h1><ul>
<li><p>操作字符串的类有：String、StringBuffer、StringBuilder</p>
</li>
<li><p>区别：String是不可变类，每次操作字符串都会生成新的String对象;另外两个可以在原有对象的基础上进行操作，所以经常改变的字符串最好不要使用String</p>
</li>
<li><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer是线程安全的，StringBuilder线程不安全，但是StringBuilder性能高于StringBuffer，单线程下推荐使用StringBuilder,多线程使用StringBuffer</p>
</li>
</ul>
<h1 id="String-类常用的方法都有哪些？"><a href="#String-类常用的方法都有哪些？" class="headerlink" title="String 类常用的方法都有哪些？"></a>String 类常用的方法都有哪些？</h1><ul>
<li>indexOf():返回指定字符串的索引</li>
<li>charAt():返回指定索引处的字符</li>
<li>replace():字符串替换</li>
<li>trim():去除字符串两端空白</li>
<li>split():分割字符串，返回一个分割后的字符数组</li>
<li>getBytes():返回字符串的byte类型数组</li>
</ul>
<h1 id="抽象类和普通类的区别？"><a href="#抽象类和普通类的区别？" class="headerlink" title="抽象类和普通类的区别？"></a>抽象类和普通类的区别？</h1><ul>
<li>普通类不能有抽象方法，抽象类可以有抽象方法</li>
<li>抽象类不能被直接实例化，普通类可以直接</li>
</ul>
<h1 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h1><ul>
<li>接口被实现，抽象类被继承</li>
<li>类可以实现多个接口，但是只能继承一个类</li>
<li>接口中不能有main方法，抽象类中可以有</li>
<li>接口不能有构造放啊发，抽象类可以有</li>
<li>接口中方法默认使用public修饰，抽象类中的方法可以是任意修饰符</li>
</ul>
<h1 id="java-io流分为几种？"><a href="#java-io流分为几种？" class="headerlink" title="java io流分为几种？"></a>java io流分为几种？</h1><ul>
<li>按功能来分：输入流(input)、输出流(output)</li>
<li>按类型来分：字节流和字符流</li>
<li>两者区别：<ul>
<li>字节流按8位 传输以字节为单位输入输出数据</li>
<li>字符流按16位传输以字节位单位输入输出数据</li>
</ul>
</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>1.冒泡排序<br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡</span></span><br><span class="line"><span class="comment"> *  注意别掉了等号 j &gt;= i+1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length-<span class="number">1</span>; j &gt;= i+<span class="number">1</span> ; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.插入排序<br><img src="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt="插入排序"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp =arr[i];</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; arr[j] ; j--) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] =arr[j];</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pos] =tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.选择排序<br><img src="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&lt; arr[i])</span><br><span class="line">                min_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = arr[i];</span><br><span class="line">        arr[i] = arr[min_index];</span><br><span class="line">        arr[min_index] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法重写和重载"><a href="#方法重写和重载" class="headerlink" title="方法重写和重载"></a>方法重写和重载</h1><ul>
<li>重写<ul>
<li>==两等两小一大==：方法名 参数列表相同 抛出异常、返回类型小于父类，修饰符大于父类</li>
</ul>
</li>
<li>重载<ul>
<li>发生在同一个类中</li>
<li>方法名相同 返回值类型相同</li>
</ul>
</li>
</ul>
<h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p><img src="exception.png" alt=""></p>
<ul>
<li>Error 和 Exception区别<ul>
<li>Error是Throwable子类，由虚拟机生成并抛出，包括动态链接失败，虚拟机错误等程序不需要处理</li>
<li>Exception 分为检查异常和运行时异常，<br>  -检查异常再编译时会被提示不通过，<pre><code>- Java.lang.ClassNotFoundException
- Java.lang.NoSuchMetodException
- java.io.IOException</code></pre><ul>
<li>运行时是运行时候的异常<ul>
<li>ava.lang.ArithmeticException</li>
<li>Java.lang.ArrayStoreExcetpion</li>
<li>Java.lang.ClassCastException</li>
<li>Java.lang.IndexOutOfBoundsException</li>
<li>Java.lang.NullPointerException</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="BIO、NIO、AIO有什么区别？"><a href="#BIO、NIO、AIO有什么区别？" class="headerlink" title="BIO、NIO、AIO有什么区别？"></a>BIO、NIO、AIO有什么区别？</h1><ul>
<li>BIO：Block IO同步阻塞式IO，模式使用方便，并发处理能力低</li>
<li>NIO：New IO 同步非阻塞IO，客户端和服务器通过Channel(通道)通讯，实现了多路复用</li>
<li>AIO：Asynchronous IO是NIO升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制</li>
</ul>
<h1 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h1><p><img src="Collection.png" alt="Collection"></p>
<ul>
<li>java.util.Collection是集合类的顶级接口；它提供了对集合对象进行基本操作的通用接口方法。</li>
<li>Collections则是集合类的一个工具类/帮助类，提供了一系列的静态方法，用于对集合中元素进行排序，搜索以及线程安全等各种操作</li>
</ul>
<h1 id="List、Set、Map之间的区别是什么？"><a href="#List、Set、Map之间的区别是什么？" class="headerlink" title="List、Set、Map之间的区别是什么？"></a>List、Set、Map之间的区别是什么？</h1><p><img src="640.jpg" alt="区别"></p>
<h1 id="HashMap-和-Hashtable有什么区别？"><a href="#HashMap-和-Hashtable有什么区别？" class="headerlink" title="HashMap 和 Hashtable有什么区别？"></a>HashMap 和 Hashtable有什么区别？</h1><ul>
<li>HashMap去掉了Hashtable的contains方法，但是加上了containsValue() 和 containsKey()方法</li>
<li>Hashtable是同步的，而HashMap是非同步的，效率更高</li>
<li>HashMap允许空键值，而Hashtable不允许</li>
</ul>
<h1 id="如何决定使用HashMap-还是-TreeMap？"><a href="#如何决定使用HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用HashMap 还是 TreeMap？"></a>如何决定使用HashMap 还是 TreeMap？</h1><ul>
<li>需要频繁插入，删除，定位元素，使用HashMap</li>
<li>需要对一个有序的key集合进行遍历，TreeMap</li>
</ul>
<h1 id="HashMap的实现原理？"><a href="#HashMap的实现原理？" class="headerlink" title="HashMap的实现原理？"></a>HashMap的实现原理？</h1><ul>
<li>HashMap概述:HashMap是基于Hash表Map接口的非同步实现，不保证有序、顺序恒久不变</li>
<li>HashMap数据结构：最基本的结构两种，数组、模拟指针(引用)，数组加链表</li>
<li>put元素过程：首先根据key的hashcode重新计算hash值，根据hash值得到数组中的下标，如果数组在该位置放了其他元素，那么在这个位置上的元素将以链表的形式存放，新加入的元素放在链头，如果数组中该位置没有元素，就直接将元素放到数组的该位置上</li>
<li>JDK 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表转为红黑树来提高查询效率，从原来的O(n)到O(logn)</li>
</ul>
<h1 id="HashSet实现原理"><a href="#HashSet实现原理" class="headerlink" title="HashSet实现原理"></a>HashSet实现原理</h1><ul>
<li>HashSet底层由HashMap实现</li>
<li>HashSet的值存放在HashMap的key上</li>
<li>HashMap的value统一为present</li>
</ul>
<h1 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h1><ul>
<li>ArrayList是数组结构，支持随机访问，而LinkedList的底层数据结构是双向循环链表，不支持随机访问。使用下表访问一个元素，ArrayList的时间复杂度是O(1),而LinkedList是O(n)</li>
</ul>
<h1 id="数组和List区别"><a href="#数组和List区别" class="headerlink" title="数组和List区别"></a>数组和List区别</h1><ul>
<li>数组可以存基本类型和对象，而ArrayList只能容纳对象</li>
<li>数组是指定大小的，而ArrayList是固定的</li>
<li>数组没有ArrayList那么多功能，比如addAll,removeAll和iterator</li>
</ul>
<h1 id="线程安全的集合有哪些？"><a href="#线程安全的集合有哪些？" class="headerlink" title="线程安全的集合有哪些？"></a>线程安全的集合有哪些？</h1><ul>
<li>vetor:同步后的arraylist</li>
<li>stack:堆栈类，先进后出</li>
<li>hashtable</li>
<li>enumeration:枚举</li>
</ul>
<h1 id="迭代器是什么？"><a href="#迭代器是什么？" class="headerlink" title="迭代器是什么？"></a>迭代器是什么？</h1><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该学列的底层结构。迭代器通常被称”轻量级”对象，因为创建它的代价小</p>
<h1 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h1><ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发指两个或者多个事件在用以时间间隔发生</li>
<li>并行是不同实体上的多个事件，并发是在同一实体上的多个事件</li>
</ul>
<h1 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h1><ul>
<li>进程是程序运行和资源分配的基本的单位，一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数</li>
<li>线程是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位</li>
</ul>
<h1 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h1><p>①继承Thread类创建线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> A().start()</span><br></pre></td></tr></table></figure>
<p>②通过Runnable接口创建线程类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"true = "</span> + <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> B()).start();</span><br></pre></td></tr></table></figure>
<p>③通过Callable和Future创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> v <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"callable thread"</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动方式一 线程启动</span></span><br><span class="line">allable&lt;String&gt; callable = <span class="keyword">new</span> C&lt;&gt;();</span><br><span class="line">Future&lt;String&gt; aTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(callable);</span><br><span class="line">Thread a = <span class="keyword">new</span> Thread((Runnable) aTask);</span><br><span class="line">a.start();</span><br><span class="line"><span class="comment">// 启动方式二 线程池启动</span></span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">Future&lt;String&gt; f = es.submit(<span class="keyword">new</span> C&lt;String&gt;());</span><br><span class="line">System.out.println(f.get());</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></table></figure>
<ul>
<li>线程池<ul>
<li>newFixedThreadPool 固定大小的线程池 阻塞式队列LinkedBlockingQueue</li>
<li>newSingleThreadExecutor 只有一个线程的线程池 LinkedBlockingQueue</li>
<li>newCachedThreadPool 缓存线程池 默认存活60s，SynchronousQueue</li>
<li>newScheduledThreadPool </li>
</ul>
</li>
</ul>
<h1 id="Runnable-和-callable"><a href="#Runnable-和-callable" class="headerlink" title="Runnable 和 callable"></a>Runnable 和 callable</h1><ul>
<li>Runnable 接口中的run()方法的返回值是void，它做的事情知识纯粹地去执行run()方法中的代码而已</li>
<li>Callable接口中的call方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
</ul>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>创建、就绪、运行、阻塞、死亡</p>
<h1 id="sleep和wait有什么区别？"><a href="#sleep和wait有什么区别？" class="headerlink" title="sleep和wait有什么区别？"></a>sleep和wait有什么区别？</h1><p>sleep():方法是线程类(Thread)的静态方法，让调用线程进入睡眠状态，不释放锁<br>wait():方法是Object类中的，当一个线程执行wait方法时，进入和一个该对象相关的等待池，释放锁</p>
<h1 id="创建线程池的集中方式"><a href="#创建线程池的集中方式" class="headerlink" title="创建线程池的集中方式"></a>创建线程池的集中方式</h1><p>①newFixedThreadPool(int nThreads)<br>②newCachedThreadPool()<br>③newSingleThreadExecutor<br>④newScheduledThreadPool(int corePoolSize)</p>
<ul>
<li>线程池状态：Running ShutDown Stop Tidying Terminated</li>
<li>线程池中的执行方法submit() execute()区别<ul>
<li>接收的参数不一样</li>
<li>submit 有返回值，而execute没有</li>
<li>submit 方便异常处理</li>
</ul>
</li>
</ul>
<h1 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h1><ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看见</li>
<li>有序性：一个程序观察其他线程中的指令顺序，由于指令重排序，该观察结果一般杂乱无序</li>
</ul>
<h1 id="多线程锁升级原理"><a href="#多线程锁升级原理" class="headerlink" title="多线程锁升级原理"></a>多线程锁升级原理</h1><p>锁有四种状态：无状态锁，偏向锁，轻量锁，重量锁<br><img src="641.jpg" alt=""><br>自旋：<br>    自旋是指某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。</p>
<p>偏向锁<br>    引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。<br>    当只有一个线程去竞争锁的时候，我们不需要阻塞，也不需要自旋，因为只有一个线程在竞争，我们只要去判断该偏向锁中的ThreadID是否为当前线程即可。如果是就执行同步代码，不是就尝试使用CAS修改ThreadID，修改成功执行同步代码，不成功就将偏向锁升级成轻量锁。</p>
<p>轻量锁<br>    获取轻量锁的过程与偏向锁不同，竞争锁的线程首先需要拷贝对象头中的Mark Word到帧栈的锁记录中。拷贝成功后使用CAS操作尝试将对象的Mark Word更新为指向当前线程的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁。如果更新失败，那么意味着有多个线程在竞争。<br>    当竞争线程尝试占用轻量级锁失败多次之后（使用自旋）轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。</p>
<p>重量锁<br>    重量级锁的加锁、解锁过程和轻量级锁差不多，区别是：竞争失败后，线程阻塞，释放锁后，唤醒阻塞的线程，不使用自旋锁，不会那么消耗CPU，所以重量级锁适合用在同步块执行时间长的情况下。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁由于锁之间嵌套造成的,四个必要条件 </p>
<ul>
<li>1.互斥使用，一个资源被一个线程使用时，别的线程不能使用</li>
<li>2.不可抢占，资源请求者不能从资源占有者手中抢夺资源</li>
<li>3.请求和保持，当资源请求者再请求其他的资源的同时，保持对原有资源的占有。</li>
<li>4.循环等待，即存在一个等待队列，P1占有P2的资源，P2占有P1的资源<br>解决办法:</li>
<li>破坏‘请求和保持’：<ul>
<li>所有进程在运行之前，必须一次性地申请在整个运行过程中所需的全部资源。</li>
<li>要求每个进程提出新的资源申请前，释放它所占有的资源。</li>
</ul>
</li>
<li>破坏：‘不可抢占’<ul>
<li>如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。</li>
</ul>
</li>
<li>破坏“循环等待”条件：<ul>
<li>将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</li>
</ul>
</li>
</ul>
<h1 id="同步锁-synchronize底层实现原理"><a href="#同步锁-synchronize底层实现原理" class="headerlink" title="同步锁 synchronize底层实现原理"></a>同步锁 synchronize底层实现原理</h1><p>synchronized可以保证方法或者代码块在运行时，同一时刻只能有一个方法可以临界区，同时它还可以保证共享变量的内存可见性</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h1 id="synchronized-和-volatile"><a href="#synchronized-和-volatile" class="headerlink" title="synchronized 和 volatile"></a>synchronized 和 volatile</h1><ul>
<li>volatile本质是在告诉jvm当前变量在寄存器(工作内存)中的值不确定，需要从主内存中读取；synchronize锁定当前变量，只有当前线程可以当问该变量，其他线程被阻塞住</li>
<li>volatile仅能使用在变量级别 synchronize可以使用在变量、方法、类</li>
<li>volatile仅实现变量的修改可见性，不能保证原子性；而synchronized则都可以保证</li>
<li>volatile不会造成线程的阻塞；synchronized会造成线程的阻塞</li>
<li>volatile变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ul>
<h1 id="synchronize-和Lock有什么区别"><a href="#synchronize-和Lock有什么区别" class="headerlink" title="synchronize 和Lock有什么区别"></a>synchronize 和Lock有什么区别</h1><ul>
<li>一个是关键字，一个是java类</li>
<li>synchronized 无法判断是否获取锁的状态，Lock可以判断是否获取到锁</li>
<li>synchronized 会自动释放锁，Lock需要在finally中释放锁，容易造成线程死锁</li>
<li>synchronized 锁可重入，不可中断，非公平，而Lock锁可重入，可判断、可公平</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题</li>
</ul>
<h1 id="synchronize-和-ReentrantLock-区别"><a href="#synchronize-和-ReentrantLock-区别" class="headerlink" title="synchronize 和 ReentrantLock 区别"></a>synchronize 和 ReentrantLock 区别</h1><p>ReentrantLock扩展了synchronized</p>
<ul>
<li>ReentrantLock可以对锁的等待事件进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知<br>两者加锁机制不一样：<ul>
<li>ReentrantLock底层调用的是Unsafe的park方法加锁</li>
<li>synchronized操作对象头中的mark word信息进行加锁</li>
</ul>
</li>
</ul>
<h1 id="atomic原理"><a href="#atomic原理" class="headerlink" title="atomic原理"></a>atomic原理</h1><ul>
<li>Atomic包中的类基本的特性就是多线程环境下，当多个线程同时对单个变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以像自旋锁一样，继续尝试，一直等待执行成功</li>
<li>sun.misc.Unsafe 这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用</li>
</ul>
<h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>反射是指程序可以访问、检测和修改它本身状态或行为的一种能力<br>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<h1 id="反射中一些方法的区别"><a href="#反射中一些方法的区别" class="headerlink" title="反射中一些方法的区别"></a>反射中一些方法的区别</h1><ul>
<li>getFields() getDeclaredFields区别<ul>
<li>getFields()返回的是申明为public的属性，包括父类中定义的</li>
<li>getDelaredFields() 返回指定类定义的所有定义的属性，不包括父类中的</li>
</ul>
</li>
</ul>
<h1 id="反射创建实例的三种方式"><a href="#反射创建实例的三种方式" class="headerlink" title="反射创建实例的三种方式"></a>反射创建实例的三种方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一 通过Class对象直接调用newInstance方法</span></span><br><span class="line">Class&lt;String&gt; clz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">String str = clz.newInstance();</span><br><span class="line">System.out.println(<span class="string">"str = "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二 调用默认Constructor对象的newInstances方法</span></span><br><span class="line">Class&lt;String&gt; clz = (Class&lt;String&gt;) Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">Constructor&lt;String&gt; cons= clz.getConstructor();</span><br><span class="line">String s = cons.newInstance();</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三 调用含参Constructor对象的newInstances方法</span></span><br><span class="line">Class&lt;String&gt; clz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor&lt;String&gt; cons = clz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String hello_world = cons.newInstance(<span class="string">"hello world"</span>);</span><br><span class="line">System.out.println( hello_world);</span><br></pre></td></tr></table></figure>

<h1 id="Class-forName和ClassLoader-loadClass有什么区别"><a href="#Class-forName和ClassLoader-loadClass有什么区别" class="headerlink" title="Class.forName和ClassLoader.loadClass有什么区别"></a>Class.forName和ClassLoader.loadClass有什么区别</h1><ul>
<li>类初加载的过程分为：加载 连接 初始化</li>
<li>Class.forNama(className,true,classloader) true表示loadClass之后必须初始化</li>
<li>ClassLoader.loadClass(className,false)目标对象被装载后不进行连接，不会去执行静态块中的内容</li>
</ul>
<h1 id="什么是Java序列化？什么情况下需要序列化"><a href="#什么是Java序列化？什么情况下需要序列化" class="headerlink" title="什么是Java序列化？什么情况下需要序列化?"></a>什么是Java序列化？什么情况下需要序列化?</h1><p>简单的说就是为了保存在内存中的各种对象的状态(将类各种属性序列化为文件)，并且可以把保存的对象再读出来。</p>
<ul>
<li>当你想把内存中的对象状态保存到一个文件中或者数据库中时</li>
<li>当你想用套接字在网络上传送对象的时候</li>
<li>当你想通过RMI传输对象的时候</li>
</ul>
<h1 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h1><ul>
<li>动态代理：当想要给实现了某个接口的类中的方法添加一些额外的处理。比如说加日志，加事务等。可以给整个类创建一个代理，这个类不仅包含原来类方法的功能，而且在原来的基础上加了额外处理的新类。这个类是动态生成的，具有解耦意义，灵活，扩展性强。<ul>
<li>Spring AOP<ul>
<li>加事务</li>
<li>加权限</li>
<li>加日志</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h1><p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个代理类Proxy，调用他的newInstance()可以产生代理对象。利用到InvocationHandler，拼接代理类源码，将其编译编译成代理类的二进制码，利用加载器加载，将其实例化产生代理对象，最后返回。</p>
<h1 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h1><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例</p>
<h1 id="如何实现对象的克隆"><a href="#如何实现对象的克隆" class="headerlink" title="如何实现对象的克隆"></a>如何实现对象的克隆</h1><ul>
<li>1）实现Cloneable接口并重写Object类中的clone()方法</li>
<li>2）实现Serializable接口，通过对象的序列化和反序列实现克隆<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span></span><br><span class="line"><span class="function">                                  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bin = </span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream</span></span><br><span class="line">        <span class="comment">//或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，</span></span><br><span class="line">        <span class="comment">//这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="深度拷贝和浅拷贝的区别是什么？"><a href="#深度拷贝和浅拷贝的区别是什么？" class="headerlink" title="深度拷贝和浅拷贝的区别是什么？"></a>深度拷贝和浅拷贝的区别是什么？</h1><ul>
<li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中的任意值，另一个值都会随之变化。</li>
<li>深度拷贝是将对象以及值复制过来，两个对象修改其中任意的值，另一个对象不受影响<br>例如：JSON.parse()和JSON.stringify()，但是无法复制方法</li>
</ul>
<h1 id="Jsp有哪些内置对象？作用分别是？"><a href="#Jsp有哪些内置对象？作用分别是？" class="headerlink" title="Jsp有哪些内置对象？作用分别是？"></a>Jsp有哪些内置对象？作用分别是？</h1><ul>
<li>9个内置对象：<ul>
<li>request:封装客户端的请求，其中包含来自get或者psot请求的参数</li>
<li>response:封装服务器对客户端的响应</li>
<li>pageContext:通过该对象可以获取其他对象</li>
<li>session:封装服务器运行环境的对象</li>
<li>application:封装服务器运行环境的对象</li>
<li>out:输出服务器响应的输出流对象</li>
<li>config:web应用的配置对象</li>
<li>page:jsp页面本身(相当于Java程序中的this)</li>
<li>exception:封装页面抛出异常的对象</li>
</ul>
</li>
<li>4大作用域<ul>
<li>page 代表与一个页面相关的对象和属性</li>
<li>request 代表与web客户机发出的一个请求相关的对象和属性</li>
<li>session 代表与某个应用与服务器建立的一次会话相关的对象和属性</li>
<li>application 代表与整个web应用程序相关的对象和属性</li>
</ul>
</li>
</ul>
<h1 id="session-和-cookie区别"><a href="#session-和-cookie区别" class="headerlink" title="session 和 cookie区别"></a>session 和 cookie区别</h1><ul>
<li>session 是在服务端保存的一个数据结构，用来跟踪用户的状态，整个数据可以保存在集群、数据库、文件中</li>
<li>cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方法</li>
</ul>
<h1 id="如何防止sql注入？"><a href="#如何防止sql注入？" class="headerlink" title="如何防止sql注入？"></a>如何防止sql注入？</h1><ul>
<li>PreparedStatement</li>
<li>使用正则表达式过滤传入的参数</li>
<li>字符串过滤</li>
<li>jsp中调用该函数检查是否包含非法字符</li>
<li>Jsp页面判断代码</li>
</ul>
<h1 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final finally finalize"></a>final finally finalize</h1><ul>
<li>final 可以修饰类，变量，方法</li>
<li>finally 一般作用在try-catch代码块中，在处理异常的时候finally中的代码块会执行</li>
<li>finalize是Object类中的一个方法，一般由垃圾收集器来调用，当我们调用<code>System.gc()</code>方法的时候，垃圾收集器调用finalize方法;调用此方法，实际上是FInalizerThread将对象从ReferenceQueue中移除，java虚拟机就可以进行回收<br><a href="https://blog.csdn.net/qq_33619378/article/details/90408073" target="_blank" rel="noopener">finalize方法原理详解</a></li>
</ul>
<h1 id="try-catch-finally-中哪部份可以省略？"><a href="#try-catch-finally-中哪部份可以省略？" class="headerlink" title="try-catch-finally 中哪部份可以省略？"></a>try-catch-finally 中哪部份可以省略？</h1><ul>
<li>catch 可以省略 </li>
</ul>
<h1 id="try-catch-finally-如果catch中return了，finally还会执行吗？"><a href="#try-catch-finally-如果catch中return了，finally还会执行吗？" class="headerlink" title="try-catch-finally 如果catch中return了，finally还会执行吗？"></a>try-catch-finally 如果catch中return了，finally还会执行吗？</h1><p>会执行，在return前执行</p>
<h1 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h1><ul>
<li>NullPointException</li>
<li>SQLException</li>
<li>IndexOutOfBoundsException</li>
<li>NumberFormatException</li>
<li>FileNotFoundException</li>
<li>IOException</li>
<li>ClassCastException</li>
</ul>
<h1 id="http响应码301和302代表什么？有什么区别"><a href="#http响应码301和302代表什么？有什么区别" class="headerlink" title="http响应码301和302代表什么？有什么区别"></a>http响应码301和302代表什么？有什么区别</h1><ul>
<li>都是HTTP状态的编码，都代表者某个URL发生了转移<ul>
<li>301 代表永久性转移</li>
<li>302 代表暂时性转移</li>
</ul>
</li>
</ul>
<h1 id="forward-和-redirect区别"><a href="#forward-和-redirect区别" class="headerlink" title="forward 和 redirect区别"></a>forward 和 redirect区别</h1><ul>
<li>Forward 一次请求和响应</li>
<li>Redirect 两次请求和响应</li>
</ul>
<h1 id="tcp-和-udp-有什么区别？"><a href="#tcp-和-udp-有什么区别？" class="headerlink" title="tcp 和 udp 有什么区别？"></a>tcp 和 udp 有什么区别？</h1><ul>
<li>1.tcp基于连接，udp无连接</li>
<li>2.tcp对系统要求的资源较多，udp较少</li>
<li>3.udp程序结构较简单</li>
<li>4.tcp流模式与udp数据包模式</li>
<li>5.tcp保证数据正确性，顺序，udp可能丢包</li>
</ul>
<h1 id="Tcp三次握手，四次挥手"><a href="#Tcp三次握手，四次挥手" class="headerlink" title="Tcp三次握手，四次挥手"></a>Tcp三次握手，四次挥手</h1><p><img src="tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="tcp三次握手"><br>第一次握手：建立连接时，客户端发送syn包(syn=x)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)<br>第二次握手：服务器收到syn包，必须确认客户端的SYN(ack=x+1)，同时自己也发送一个SYN包(syn=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手：客户端收到收到服务器SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完比，客户端和服务器连接成功，完成三次握手</p>
<p><img src="%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"><br>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p><img src="f58f6ad856c6802b636d20d8f5ba2c3e.jpeg" alt=""></p>
<ul>
<li>应用层：网络服务与最终用户的一个接口</li>
<li>表示层：数据的表示，安全，压缩</li>
<li>会话层：建立管理终止会话</li>
<li>传输层：定义传输数据的协议端口号，以及流空和差错校验</li>
<li>网络层：进行逻辑地址寻址，实现不用网络之间的路径选择</li>
<li>数据链路层：建立逻辑连接，进行硬件地址寻址，差错校验等功能</li>
<li>物理层：建立、维护、断开物理连接</li>
</ul>
<h1 id="get和post请求有哪些区别"><a href="#get和post请求有哪些区别" class="headerlink" title="get和post请求有哪些区别"></a>get和post请求有哪些区别</h1><ul>
<li>get在浏览器回退时是无害的，而Post会再次提交请求</li>
<li>get产生URL地址可以被Bookmark，而Post不可以</li>
<li>get请求会被浏览器主动cache,而Post不会，除非手动设置</li>
<li>get请求只能进行url编码，而Post支持多种编码方法</li>
<li>get请求参数会被完整保留在浏览器历史记录里，而Post中的参数不会被保留</li>
<li>get请求参数长度有限制，而post没有</li>
<li>参数类型，get只接收ASCII字符，而post没有限制</li>
<li>Get比Post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>
<li>Get参数通过URL传递，Post放在Request　Body中</li>
</ul>
<p>＃　如何实现跨域</p>
<ul>
<li><p>1.图片ping或者script标签跨域</p>
<ul>
<li>图片ping常用于跟踪用户点击页面或动态广告曝光次数。 </li>
<li>script标签可以得到从其他来源数据，这也是JSONP依赖的根据</li>
</ul>
</li>
<li><p>2.JSONP跨域</p>
<ul>
<li>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 script元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。 </li>
<li>只能使用Get请求</li>
<li>不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败</li>
<li>JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保</li>
</ul>
</li>
<li><p>3.CORS</p>
<ul>
<li>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
设置跨域携带参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;Access-Control-Allow-Credentials&quot;: true</span><br><span class="line">&#x2F;&#x2F; Ajax设置</span><br><span class="line">&quot;withCredentials&quot;: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JASONP 实现原理</p>
<ul>
<li>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</li>
</ul>
</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li><p>1.单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">       instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> instance;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">return</span> instance;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重校验锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.观察者模式</p>
</li>
<li><p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</li>
<li><p>3.装饰者模式</p>
</li>
<li><p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。</p>
</li>
<li><p>4.适配器模式</p>
</li>
<li><p>5.工厂模式</p>
<ul>
<li>抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品</li>
</ul>
</li>
<li><p>6.代理模式(proxy)</p>
<ul>
<li>静态代理</li>
</ul>
</li>
</ul>
<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><ul>
<li><p>它是一个轻量级的控制反转(IOC)和面向切面的容器框架</p>
<ul>
<li>控制反转：通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它</li>
<li>面向切面：Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
</ul>
</li>
<li><p>Spring容器包含并管理应用对象的配置和生命周期，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</p>
</li>
<li><p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p>
</li>
</ul>
<h1 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP  IOC"></a>AOP  IOC</h1><ul>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构</p>
</li>
<li><p>依赖注入<br><img src="640.webp" alt=""></p>
</li>
</ul>
<h1 id="spring-常用注入方式"><a href="#spring-常用注入方式" class="headerlink" title="spring 常用注入方式"></a>spring 常用注入方式</h1><ul>
<li>构造方法注入</li>
<li>setter注入</li>
<li>基于注解注入</li>
</ul>
<h1 id="spring-bean作用域"><a href="#spring-bean作用域" class="headerlink" title="spring bean作用域"></a>spring bean作用域</h1><ul>
<li>singleton<ul>
<li>对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为,默认使用模式</li>
</ul>
</li>
<li>prototype<ul>
<li>程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</li>
</ul>
</li>
<li>request</li>
<li>session</li>
<li>globalsession</li>
</ul>
<h1 id="spring自动装载bean的方式"><a href="#spring自动装载bean的方式" class="headerlink" title="spring自动装载bean的方式"></a>spring自动装载bean的方式</h1><ul>
<li>隐式的bean发现机制和自动装配</li>
<li>在Java代码或者行xml中进行显式配置</li>
</ul>
<h1 id="spring-事务实现方法"><a href="#spring-事务实现方法" class="headerlink" title="spring 事务实现方法"></a>spring 事务实现方法</h1><ul>
<li>编程式事务管理对基于POJO的应用来说是唯一的选择，我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法</li>
<li>基于TransactionProxyFactoryBean的声明式事务管理</li>
<li>基于@Transactional的声明式事务管理</li>
<li>基于Aspect AOP配置事务</li>
</ul>
<h1 id="spring事务隔离"><a href="#spring事务隔离" class="headerlink" title="spring事务隔离"></a>spring事务隔离</h1><ul>
<li><p>脏读：一个事务读到另一个事务未提交的更新数据。</p>
</li>
<li><p>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p>
</li>
<li><p>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</p>
</li>
</ul>
<h1 id="spring-MVC-运行流程"><a href="#spring-MVC-运行流程" class="headerlink" title="spring MVC 运行流程"></a>spring MVC 运行流程</h1><p><img src="641.webp" alt=""></p>
<ul>
<li>客户端发出一个请求web服务请求，DispatchServlet将请求转给处理器映射器HandlerMapping,HM根据url找到对应的处理器适配器</li>
<li>处理器适配器调用处理器相应的功能，处理器返回ModelAndView给处理器适配器，处理器适配器返回给前端控制器</li>
<li>前端控制器解析视图viewResolver,然后将解析之后的参数放入到view中，并返回给客户端</li>
</ul>
<h1 id="RequestMapping的作用是什么？"><a href="#RequestMapping的作用是什么？" class="headerlink" title="@RequestMapping的作用是什么？"></a>@RequestMapping的作用是什么？</h1><ul>
<li>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li>
</ul>
<h1 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h1><p>spring boot 是一个框架，一种全新的编程规范，它的生产简化了框架的使用，简化了Spring众多框架中所需的大量且繁琐的配置文件，所以SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p>
<h1 id="为什么要用Spring-boot"><a href="#为什么要用Spring-boot" class="headerlink" title="为什么要用Spring boot"></a>为什么要用Spring boot</h1><ul>
<li>Spring Boot 使编码变简单</li>
<li>Spring Boot 使配置变简单</li>
<li>Spring Boot 使部署简单</li>
<li>Spring Boot 使监控变简单</li>
</ul>
<h1 id="spring-boot配置我呢见有哪几种-？有什么区别"><a href="#spring-boot配置我呢见有哪几种-？有什么区别" class="headerlink" title="spring boot配置我呢见有哪几种 ？有什么区别"></a>spring boot配置我呢见有哪几种 ？有什么区别</h1><ul>
<li>Spring Boot提供了两种常用的配置文件properties文件和yml文件</li>
<li>相对于properties文件而言，yml文件更年轻，会因为空格破坏了层级关系</li>
</ul>
<h1 id="Spring-Boot实现热部署"><a href="#Spring-Boot实现热部署" class="headerlink" title="Spring Boot实现热部署"></a>Spring Boot实现热部署</h1><ul>
<li>1.使用 spring loaded<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;!-- springBoot编译插件--&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                    &lt;!-- spring热部署 --&gt;</span><br><span class="line">                    &lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;springloaded&lt;&#x2F;artifactId&gt;</span><br><span class="line">                        &lt;version&gt;1.2.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">                    &lt;&#x2F;dependency&gt;</span><br><span class="line">                &lt;&#x2F;dependencies&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure></li>
<li>2.使用spring-boot-devtools<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热部署jar--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="什么使spring-cloud"><a href="#什么使spring-cloud" class="headerlink" title="什么使spring cloud"></a>什么使spring cloud</h1><ul>
<li><p>spring cloud 就是致力于分布式系统、云服务的框架</p>
</li>
<li><p>提供了快速构建分布式系统中一些常见模式的工具</p>
</li>
<li><p>NetFlix Eureka：一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p>
</li>
<li><p>NetFlix Ribbon：主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</p>
</li>
<li><p>Netflix Hystrix：断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作</p>
</li>
<li><p>Netflix Zuul:类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p>
</li>
<li><p>Spring Cloud Config：这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>
</li>
</ul>
<h1 id="mybatis-中使用-和"><a href="#mybatis-中使用-和" class="headerlink" title="mybatis 中使用#{} 和${}"></a>mybatis 中使用#{} 和${}</h1><ul>
<li>#{}预编译的 ${}是替换字段</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement 的set方法来赋值</li>
<li>MyBatis在处理${}时，就是把${}替换为变量的值</li>
<li>使用#{}可以有效的防止SQL注入攻击，提高系统的安全性</li>
</ul>
<h1 id="mybatis-有几种分页方式"><a href="#mybatis-有几种分页方式" class="headerlink" title="mybatis 有几种分页方式"></a>mybatis 有几种分页方式</h1><ul>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ul>
<h1 id="Mybatis逻辑分页和物理分页的区别是什么？"><a href="#Mybatis逻辑分页和物理分页的区别是什么？" class="headerlink" title="Mybatis逻辑分页和物理分页的区别是什么？"></a>Mybatis逻辑分页和物理分页的区别是什么？</h1><ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度也并不一定快于物理分页</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加到应用端来，就算速度上存在优势，然后其它性能上的优点足以弥补整个缺点</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><ul>
<li><p>类加载器分类：每一个类加载器都有一个独立的名命空间</p>
<ul>
<li>启动类加载器：是虚拟机自身的一部分，用来加载JAVA_HOME/lib/目录中的类</li>
<li>扩展类加载器：负责加载java.ext.dirs系统变量指定的路径中所有的类库</li>
<li>应用程序类加载器：负责加载用户类路径上的指定类库，默认使用的类加载器</li>
</ul>
</li>
<li><p>如果一个类加载器收到了类加载的请求，它首先不会去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的加载器都是如此，这样所有的加载请求会被传到顶层的启动类加载器中，只有当父类加载无法完成加载请求时，子加载器才会尝试去加载类<br><img src="425.png" alt=""></p>
</li>
</ul>
<h1 id="类加载执行过程"><a href="#类加载执行过程" class="headerlink" title="类加载执行过程"></a>类加载执行过程</h1><ul>
<li>加载：根据查找路径找到相应的class文件然后导入</li>
<li>检查：检查加载的class文件的正确性</li>
<li>准备：给类中的静态变量分配内存空间</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标识，直接指向内存中的地址。</li>
<li>初始化：对静态变量和静态代码块行执行初始化工作</li>
</ul>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>boolean 1字节   true false            false<br>byte    1字节   -2^7   ~  2^7-1       0<br>char    2字节   0      ~  2^16-1      \u0000<br>short   2字节   -2^15  ~  2^15-1      0<br>int     4字节   -2^31  ~  2^31-1      0<br>float   4字节                         0f<br>long    8字节   -2^63  ~  2^63-1      0L<br>double  8字节                         0d</p>
<h1 id="String类可以被继承吗？为什么"><a href="#String类可以被继承吗？为什么" class="headerlink" title="String类可以被继承吗？为什么"></a>String类可以被继承吗？为什么</h1><p>不可以，因为String类被final修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"ABCD"</span>;</span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"ABCD"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="20200412234359327.png" alt=""></p>
<ul>
<li>两种方式是有区别的<ul>
<li>前者会创建1或者0个对象，后者创建1或者2个对象<ul>
<li>前者字符串常量池中如果有，则直接引用；</li>
<li>后者在堆内存中创建一个实例对象去引用常量池中的对象；</li>
</ul>
</li>
<li>变量和引用存储在栈中，常量存储在常量池中</li>
<li>为提升JVM虚拟机性能，避免字符串重复创建，项目中还是尽量不要使用new String(“xxxx”)<br><a href="https://blog.csdn.net/Xin6Yang/article/details/88842671" target="_blank" rel="noopener">详情请参考</a></li>
</ul>
</li>
</ul>
<h1 id="ArrayList-和-LinkedList-有什么区别"><a href="#ArrayList-和-LinkedList-有什么区别" class="headerlink" title="ArrayList 和 LinkedList 有什么区别"></a>ArrayList 和 LinkedList 有什么区别</h1><p>ArrayList 和 LinkedList都实现了List接口</p>
<ul>
<li>ArrayList底层是数据，时间复杂度为O(1);LinkedList底层是链表，时间复杂度为O(n)</li>
<li>LinkedList插入，添加，删除操作速度更快；ArrayList查找较快</li>
<li>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向后一个元素</li>
</ul>
<h1 id="类的实例化顺序new-的时候是怎么样的？"><a href="#类的实例化顺序new-的时候是怎么样的？" class="headerlink" title="类的实例化顺序new()的时候是怎么样的？"></a>类的实例化顺序new()的时候是怎么样的？</h1><ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类的静态变量</li>
<li>子类静态代码块</li>
<li>父类非静态变量</li>
<li>父类构造函数</li>
<li>子类非静态变量</li>
<li>子类构造函数<ul>
<li>静态变量 静态代码块 非静态变量 构造函数</li>
</ul>
</li>
</ul>
<h1 id="哪些情况会触发类的初始化"><a href="#哪些情况会触发类的初始化" class="headerlink" title="哪些情况会触发类的初始化"></a>哪些情况会触发类的初始化</h1><ul>
<li>new创建类实例</li>
<li>访问某个类的或者接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射<code>class.forName(&quot;com.xxx.xxx&quot;)</code></li>
<li>初始化一个类的子类</li>
<li>java虚拟机启动时被标名为启动类的类</li>
</ul>
<h1 id="HashMap-HashTable-LinkedHashMap-TreeMap"><a href="#HashMap-HashTable-LinkedHashMap-TreeMap" class="headerlink" title="HashMap HashTable LinkedHashMap TreeMap"></a>HashMap HashTable LinkedHashMap TreeMap</h1><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">详细地址</a><br>HashMap(数组+链表+红黑树)</p>
<ul>
<li><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，，但是遍历顺序是不确定的。</p>
</li>
<li><p>HashMap最多只允许一条记录的键为null,允许多条值为null</p>
</li>
<li><p>HashMap线程不安全，可以使用Collections.synchronizedMap()方法或者使用ConcurrentHashMap</p>
</li>
<li><p>扩容机制</p>
<ul>
<li>Node[] table 的初始化长度(默认为16)，load factor负载因子，threshold是HashMap所能容纳的最大数据量的Node个数。threshold = length * loadfactor</li>
<li>如果超过threshold在相应的length * load factor的最大数目，就会重新resize(扩容)，扩容之后HashMap的容量是之前的两倍，默认负载因子0.75是对空间和时间效率的一个平衡选择。</li>
<li>哈希桶数组的table长度大小必须为2的n次方，这是一种非常规设计，这主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也</li>
</ul>
</li>
<li><p>线程是安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap,因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以使用ConcurrentHashMap替换</p>
</li>
</ul>
<p>LinkedHashMap</p>
<ul>
<li>它是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定先插入，也可以在构造时带参，按照访问次序排序</li>
</ul>
<p>TreeMap</p>
<ul>
<li><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键升序排序，也可以指定排序的比较器，当使用TreeMap时，key必须实现Comparable接口，或者在构造TreeMap传入自定义的Comparator,否则会在运行时抛出java.lang.ClassCastException</p>
</li>
<li><p>对于上面四种Map类型，要求映射的key是不可变对象，不可变对象是该对象在创建后它的哈希值不会被改变，如果对象哈希值发生变化，Map对象很可能就定位不到映射的位置</p>
</li>
</ul>
<h1 id="动态代理有哪几种实现方式，有什么区别？"><a href="#动态代理有哪几种实现方式，有什么区别？" class="headerlink" title="动态代理有哪几种实现方式，有什么区别？"></a>动态代理有哪几种实现方式，有什么区别？</h1><p>Jdk动态代理<br>CGlib动态代理</p>
<ul>
<li>区别<ul>
<li>jdk动态代理由java内部的反射机制来实现的(基于接口)，cglib动态代理底层则式借助asm来实现的(基于类)</li>
</ul>
</li>
<li>相同<ul>
<li>代理类对target对象的方法进行拦截，让代理类持有target对象的引用，当外部引用aop包围方法时，调用的其实是代理类对应的方法，代理类持有target对象，便可以控制target方法执行时的全方位拦截<br><a href="https://blog.csdn.net/HEYUTAO007/article/details/49738887" target="_blank" rel="noopener">详情参考</a></li>
</ul>
</li>
</ul>
<h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用域     当前类 同一package   子孙类 其他package </span><br><span class="line">public      √       √           √       √ </span><br><span class="line">protected   √       √           √       × </span><br><span class="line">default     √       √           ×       × </span><br><span class="line">private     √       ×           ×       × </span><br><span class="line">default权限比protected小，少了一个子孙类可用</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/weixin_43495390/article/details/86533482" target="_blank" rel="noopener">原文地址</a></p>
<h1 id="jvm-调优"><a href="#jvm-调优" class="headerlink" title="jvm 调优"></a>jvm 调优</h1><p>内存泄漏</p>
<ul>
<li>java.lang.OutOfMemoryError: Java heap space 堆满</li>
<li>java.lang.OutOfMemoryError: PermGen space 持久代满</li>
<li>java.lang.StackOverflowError 栈溢出</li>
<li>Fatal: Stack size too small 线程数过多</li>
<li>java.lang.OutOfMemoryError: unable to create new native thread 系统内存被沾满<br>优化方法：</li>
<li>优化GC：<ul>
<li>1.适当调整-XX:ServivorRatio的比例</li>
<li>2.选择适合自己业务的垃圾收集器，web服务一般是ParNew+CMS</li>
<li>3.调整jvm老年代，新生代以及持久代的比例，测试出一个比较满意的值</li>
<li>4.设置-XX:MaxTenuringThreshold 让新生代提前进入老年代，减少在survivor区域的复制</li>
<li>5.调整 -XX:CMSInitiatingOccupancyFraction=60，控制minor gc频率</li>
<li>6.-XX+UseCMSCompactAtFullCollection消除cms碎片</li>
</ul>
</li>
</ul>
<h1 id="tomcat-调优"><a href="#tomcat-调优" class="headerlink" title="tomcat 调优"></a>tomcat 调优</h1><ul>
<li>内存优化 主要是对tomcat启动参数进行优化</li>
<li>修改最小空闲连接数，提高系统处理性能</li>
<li>优化缓存，打开压缩功能，修改参数，压缩输出内容默认大小为2kb</li>
</ul>
<h1 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h1><p>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。<br><a href="https://yq.aliyun.com/articles/10525" target="_blank" rel="noopener">原文地址</a></p>
<h1 id="countdownLatch-和-cyclicBarrier-的内部原理和用法"><a href="#countdownLatch-和-cyclicBarrier-的内部原理和用法" class="headerlink" title="countdownLatch 和 cyclicBarrier 的内部原理和用法"></a>countdownLatch 和 cyclicBarrier 的内部原理和用法</h1><p>CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它运行一个或者多个线程一直处于等待状态。<br>CyclicBarrier要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>CyclicBarrier初始化的时候，设置一个屏障数。线程调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>前者是递减，不可循环，后者是递加，可循环用</p>
<h1 id="Mysql和oracle区别"><a href="#Mysql和oracle区别" class="headerlink" title="Mysql和oracle区别"></a>Mysql和oracle区别</h1><p>1.Mysql 中from 后面是子查询表，那么必须有别名<br>2.连接字符串Oracle || ,Mysql concat 方法<br>3.Mysql没有Oracle的动态游标，只有显示游标<br>4.Mysql的group by中可以是没有被select中的字段，Oracle中就会报错<br>5.数据类型 varchar2 number 对应mysql中的 varchar int 类型<br>6.mysql的非空字段有空的内容，oracle定义了非空的字段就不能有空内容<br>7.mysql中用limit(offset,count)分页，oracle中使用rownum&lt;100来进行分页</p>
<h1 id="fail-fast-和fail-safe区别"><a href="#fail-fast-和fail-safe区别" class="headerlink" title="fail-fast 和fail-safe区别"></a>fail-fast 和fail-safe区别</h1><p>fail-fast原理：当迭代器遍历集合中的内容时，迭代器中由一个参数modCount，当集合中的元素被修改，modCount会改变，迭代器遍历下一个元素时，发现modCount!=expectedmodeCount时，就抛出异常Current modification exception<br>fail-safe:由于迭代时是对原集合的拷贝进行遍历，所以遍历过程中对原集合所作的修改并不能被迭代器检测到<br>fail-safe会比较占内存，并且读取到的数据可能不是最新的 例子：CopyOnWriteArrayList ConcurrentHashMap</p>
<h1 id="socket-编程如果断电了，服务器如何快速知道？"><a href="#socket-编程如果断电了，服务器如何快速知道？" class="headerlink" title="socket 编程如果断电了，服务器如何快速知道？"></a>socket 编程如果断电了，服务器如何快速知道？</h1><p>使用Tcp 的Keepalive机制,tcp 内嵌由心跳包，以服务端为例，当server检测到超过一定时间没有数据传输，那么会向client端发送一个keepalive packet</p>
<h1 id="drop-truncate-delete"><a href="#drop-truncate-delete" class="headerlink" title="drop truncate delete"></a>drop truncate delete</h1><ul>
<li><p>delete是每次删除一行或者多行</p>
</li>
<li><p>truncate是删除整个表中的数据，包括索引，保留一张空表</p>
</li>
<li><p>drop则是删除整张表</p>
</li>
<li><p>drop 删除表，视图，索引 </p>
</li>
<li><p>delete truncate删除表中数据</p>
</li>
</ul>
<h1 id="Bean工厂和Application-Context有什么区别"><a href="#Bean工厂和Application-Context有什么区别" class="headerlink" title="Bean工厂和Application Context有什么区别"></a>Bean工厂和Application Context有什么区别</h1><p>BeanFactory:是Spring框架最核心的接口，它提供了高级IOC的配置机制<br>ApplicationContext:建立在BeanFactory的基础之上<br>BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean才实例化它<br>；而ApplicationContext则时在初始化应用的时候就实例化所有单例对象的Bean</p>
<h1 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h1><p>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
<h1 id="一次HTTP请求到浏览器呈现页面都发生了什么"><a href="#一次HTTP请求到浏览器呈现页面都发生了什么" class="headerlink" title="一次HTTP请求到浏览器呈现页面都发生了什么"></a>一次HTTP请求到浏览器呈现页面都发生了什么</h1><ul>
<li>1.浏览器通过url中的域名查找对应的ip,首先检查本地是否有对应的ip,没有就回去DNS服务器上查找</li>
<li>2.浏览器通过ip加url端口跟服务器建立tcp连接(三次握手)</li>
<li>3.浏览器向服务器发送http请求</li>
<li>4.服务器收到浏览器请求并返回http响应</li>
<li>5.浏览器解析渲染页面</li>
<li>6.断开tcp连接，四次挥手</li>
</ul>
<h1 id="http-1-0-和-http-1-1的区别"><a href="#http-1-0-和-http-1-1的区别" class="headerlink" title="http 1.0 和 http 1.1的区别"></a>http 1.0 和 http 1.1的区别</h1><ol>
<li>http 1.1支持长连接，和请求的流水线处理</li>
</ol>
<ul>
<li>在请求完毕时，客户端会使用Connection请求头值为Keep-Alive通知服务器，保持连接。在服务器响应之前，客户端可以发送新请求，服务器会按请求顺序依次响应。</li>
</ul>
<ol start="2">
<li>http 1.1增加host字段 比如Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li>
<li>100(Continue)状态码，允许客户端在发送request body之前先用request header试探以下，如果服务器允许，再发送request body</li>
<li>http/1.1 中引入了chunked transfer-coding来解决数据块过大的问题，切割数据块，最后用一个零长度的块作为消息结束的标识，避免缓冲整个消息造成过载</li>
<li>http/1.1在1.0基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与服务器进行重新激活</li>
</ol>
<h1 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h1><p><img src="springboot.webp" alt="springboot"></p>
<ul>
<li>第一部分：SpringApplication的初始化，配置一些基本的环境变量、资源、构造器、监听器</li>
<li>第二部份：实现了应用具体的启动方法，包括启动流程的监听模块、加载配置环境模块、以及核心的创建上下文环境模块</li>
<li>第三部分：自动化配置模块，该模块作为springboot自动配置核心</li>
</ul>
<h1 id="redis-AOF-和RDB区别"><a href="#redis-AOF-和RDB区别" class="headerlink" title="redis AOF 和RDB区别"></a>redis AOF 和RDB区别</h1><p>RDB：实时快照方法，定时备份，记录了数据的变更<br>AOF：基于语句追加方法，记录了整个写操作</p>
<h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><ul>
<li>String Hash(双层Map结构) </li>
<li>List(双向链表结构lpush插入数据 lpop移除数据) </li>
<li>Set 元素不能重复无序</li>
<li>Zset 元素不能重复有序</li>
</ul>
<h1 id="redis-分片连接池-采用一致性Hash算法"><a href="#redis-分片连接池-采用一致性Hash算法" class="headerlink" title="redis 分片连接池 采用一致性Hash算法"></a>redis 分片连接池 采用一致性Hash算法</h1><ul>
<li>放入元素时计算hash，(key.hashCode()&amp;Integer.MAX_VALUE)%N</li>
<li>一个0 ~ 2^32-1整数区间的Hash环，散列算法实现数据映射到0-43亿整数区间</li>
<li>为了平衡节点数据量，Jedis中引入了虚拟节点，160 * weght权重值个</li>
</ul>
<h1 id="redis-cluster如何确定哪个槽道由哪个节点管理"><a href="#redis-cluster如何确定哪个槽道由哪个节点管理" class="headerlink" title="redis-cluster如何确定哪个槽道由哪个节点管理"></a>redis-cluster如何确定哪个槽道由哪个节点管理</h1><ul>
<li>redis通过一个二进制 0 1数组 和 一个保存对象引用的数组维持槽道所属权</li>
<li>两个数组的长度均为 16384，槽道数长度</li>
</ul>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>倒排索引是 “单词-文档矩阵”的一种具体存储形式</p>
<h1 id="mycat原理"><a href="#mycat原理" class="headerlink" title="mycat原理"></a>mycat原理</h1><p>mycat主要通过对sql的拦截，然后经过一定规则的分片解析，路由分析，读写分离分析，缓存分析等，然后将sql发送给后端真实的数据块，并将返回的结果做适当处理返回给客户端</p>
<h1 id="sso单点登陆实现原理"><a href="#sso单点登陆实现原理" class="headerlink" title="sso单点登陆实现原理"></a>sso单点登陆实现原理</h1><p><img src="mvgyfyd1cq.jpeg" alt="sso"></p>
<ul>
<li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li>
<li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统1</li>
<li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统2的受保护资源</li>
<li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li>
<li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li>
<li>sso认证中心校验令牌，返回有效，注册系统2</li>
<li>系统2使用该令牌创建与用户的局部会话，返回受保护资源<br>　   用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</li>
</ul>
<p>局部会话存在，全局会话一定存在<br>全局会话存在，局部会话不一定存在<br>全局会话销毁，局部会话必须销毁<br><a href="https://cloud.tencent.com/developer/article/1166255" target="_blank" rel="noopener">详情参考</a></p>
<ul>
<li>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明<br><img src="w0719vs47g.jpeg" alt=""></li>
<li>用户向系统1发起注销请求</li>
<li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li>
<li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li>
<li>sso认证中心向所有注册系统发起注销请求</li>
<li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li>
<li>sso认证中心引导用户至登录页面</li>
</ul>
<h1 id="父子节点自关联"><a href="#父子节点自关联" class="headerlink" title="父子节点自关联"></a>父子节点自关联</h1><p>父节点.字段 = 子节点.字段</p>
<h1 id="大表小表查询"><a href="#大表小表查询" class="headerlink" title="大表小表查询"></a>大表小表查询</h1><p>大表放后面进行join</p>
<h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><ul>
<li>相同点<ul>
<li>两者都是抽象类，都不能实例化</li>
<li>interface实现类</li>
</ul>
</li>
<li>不同点<ul>
<li>抽象类相当于接口和类之间的过渡</li>
<li>interface强调特定功能的实现 ,而抽象类强调所属关系</li>
<li>需要实现特定的功能，这些功能之间没有关系</li>
<li>不想让子类实现所有接口中的方法，这个时候就可以使用抽象类实现不需要重写的方法</li>
</ul>
</li>
</ul>
<h1 id="删除重复行"><a href="#删除重复行" class="headerlink" title="删除重复行"></a>删除重复行</h1><p>DELETE FROM table WHERE id NOT IN<br>    (SELECT MAX(id) FROM table GROUP BY date);</p>
<h1 id="oracle-分页"><a href="#oracle-分页" class="headerlink" title="oracle 分页"></a>oracle 分页</h1><p>SELECT *<br>FROM (SELECT ROWNUM AS rowno, t.*<br>FROM emp t<br>WHERE hire_date BETWEEN TO_DATE (‘20060501’, ‘yyyymmdd’)<br>AND TO_DATE (‘20060731’, ‘yyyymmdd’)<br>AND ROWNUM &lt;= 20) table_alias<br> WHERE table_alias.rowno &gt;= 10;</p>
<h1 id="final-finally-finalize-1"><a href="#final-finally-finalize-1" class="headerlink" title="final finally finalize"></a>final finally finalize</h1><p>final：java中的关键字，修饰符。<br>A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.<br>　　1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。<br>　　2)被声明final的方法只能使用，不能重载。<br>finally：java的一种异常处理机制。<br>　　finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。<br>finalize：Java中的一个方法名。<br>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</p>
<h1 id="为什么要有垃圾收集"><a href="#为什么要有垃圾收集" class="headerlink" title="为什么要有垃圾收集"></a>为什么要有垃圾收集</h1><ul>
<li>清理无用对象，防止内存泄漏</li>
<li>不断清理提高内存复用</li>
<li>GC的回收时间是不确定的，即使你显示的调用的System.gc()。因为和线程优先级有关</li>
<li>使用了finalize（）方法之后，GC是在这个方法执行之后的下一次进行垃圾的回收。</li>
</ul>
<h1 id="常识题"><a href="#常识题" class="headerlink" title="常识题"></a>常识题</h1><p>定义包装类 赋值一个基本类型会自动装箱，-128 ~ 127会是同一个对象</p>
<h1 id="ConcurrentHashMap-1-7和1-8区别"><a href="#ConcurrentHashMap-1-7和1-8区别" class="headerlink" title="ConcurrentHashMap 1.7和1.8区别"></a>ConcurrentHashMap 1.7和1.8区别</h1><p><a href="https://baijiahao.baidu.com/s?id=1617089947709260129&wfr=spider&for=pc" target="_blank" rel="noopener">详情参考</a></p>
<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>事务特点 （ACID）</p>
<ul>
<li><p>原子性(Automicity)：指事务是一个不可分割的单位，在这个单位中所有操作<br>全部成功或者失败；</p>
</li>
<li><p>一致性(Consistency)：是指事务执行前后，数据在完整性上仍然保持一致的特性；</p>
</li>
<li><p>隔离性(Isolation)：事务库中可以通知执行多个事务，防止多个事务直接互相影响，<br>需要将这些事务分开，分开的方式就是利用隔离性来操作，隔离性本质式在解决线程安全问题；</p>
</li>
<li><p>持久性(Durability)：事务一旦提交，则会在数据库中发生真实的修改，这个过<br>程不可逆，一回滚，事务会撤销回原有的数据内容；</p>
</li>
<li><p>隔离安全</p>
<ul>
<li>脏读:   一个事务读取到另一个事务没有提交的数据；</li>
<li>重复读:  一个事务读取到另一个事务已经提交的数据；</li>
<li>虚度/幻读： 在整表操作中，一个事务读取到另外一个事务已经提交的事务；</li>
</ul>
</li>
<li><p>隔离级别</p>
<ul>
<li><p>为了防止事务之间的互相影响的问题，而建立的；</p>
<ul>
<li>read uncommitted  最低隔离级别，不能防止脏读、不可重复读，虚读/幻读；</li>
<li>read committed    较低的隔离级别可以防止脏读、不可以防止重复读，虚读/幻读；</li>
<li>repeatable read   较高的隔离级别可以防止脏读、重复读，不可以防止虚读/幻读(mysql default)；</li>
<li>serializable      最高的数据库隔离级别，可以防止脏读、重复读、虚读/幻读；<ul>
<li>在serializable隔离级别下，数据库将以串行的方式运行;</li>
</ul>
</li>
<li>修改数据库服务器的隔离级别，需要重启服务器<ul>
<li>set global transaction isolation level repeatable read;</li>
</ul>
</li>
<li>设置窗口隔离级别<ul>
<li>set session transaction isolation level repeatable read;</li>
</ul>
</li>
<li>只对下一个事务生效<ul>
<li>set transaction isolation level repeatable read;</li>
</ul>
</li>
</ul>
</li>
<li><p>查看隔离级别 select @@tx_isolation;<br><img src="11464886-82267cb5926d26fb.webp" alt=""></p>
</li>
</ul>
</li>
</ul>
<h1 id="Autowired-Resource区别"><a href="#Autowired-Resource区别" class="headerlink" title="@Autowired @Resource区别"></a>@Autowired @Resource区别</h1><p>@Autowired是默认按照类型装配的 @Resource默认是按照名称装配的 如果没有配置name属性值则先按名字查找，找不到则按类型查找</p>
<h1 id="遍历HashMap的四种方法"><a href="#遍历HashMap的四种方法" class="headerlink" title="遍历HashMap的四种方法"></a>遍历HashMap的四种方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一 通过keySet遍历</span></span><br><span class="line"><span class="keyword">for</span> (String key:map.keySet())</span><br><span class="line">    System.out.println(<span class="string">"Key: "</span>+key+<span class="string">" Value: "</span>+map.get(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二 通过Map.entrySet使用iterator遍历Key和 value</span></span><br><span class="line">Iterator mapI = map.entrySet().Iterator();</span><br><span class="line"><span class="keyword">while</span> (mapI.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String,String&gt; entry = (Entry&lt;String,String&gt;) mapI.next();</span><br><span class="line">    System.out.println(<span class="string">"Key: "</span>+entry.getKey()+<span class="string">" Value: "</span>+entry.getValue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种 通过Map.entrySet 遍历key 和value 推荐使用</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Key: "</span>+ entry.getKey()+ <span class="string">" Value: "</span>+entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种 通过Map.values()遍历所有的value</span></span><br><span class="line"><span class="keyword">for</span> (String v: map.values())</span><br><span class="line">    System.out.println(<span class="string">"value"</span> + v);</span><br></pre></td></tr></table></figure>

<h1 id="eureka-的发现服务以及保证存活机制"><a href="#eureka-的发现服务以及保证存活机制" class="headerlink" title="eureka 的发现服务以及保证存活机制"></a>eureka 的发现服务以及保证存活机制</h1><p>当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等</p>
<p>Eureka Client会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔。</p>
<p>Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务从而进行远程调用，该注册列表信息(每30s)更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。</p>
<h1 id="如何实现基于AOP来记录所有的新增，修改，删除"><a href="#如何实现基于AOP来记录所有的新增，修改，删除" class="headerlink" title="如何实现基于AOP来记录所有的新增，修改，删除"></a>如何实现基于AOP来记录所有的新增，修改，删除</h1><h1 id="空字符串str-为null时，str-toString-、-String-str、String-valueOf-str-、分别会出现什么情况？"><a href="#空字符串str-为null时，str-toString-、-String-str、String-valueOf-str-、分别会出现什么情况？" class="headerlink" title="空字符串str 为null时，str.toString()、(String)str、String.valueOf(str)、分别会出现什么情况？"></a>空字符串str 为null时，str.toString()、(String)str、String.valueOf(str)、分别会出现什么情况？</h1><p>空指针异常 正常运行 正常运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String中的 valueOf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//String中的 toString</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Oracle跟MySql分页关键字"><a href="#Oracle跟MySql分页关键字" class="headerlink" title="Oracle跟MySql分页关键字"></a>Oracle跟MySql分页关键字</h1><p>rowNum limit</p>
<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><p>read uncommited<br>read commited   防止脏读<br>repeatable      防止脏读 重复读 default 级别<br>serializable    防止脏读 重复度 幻读</p>
<h1 id="spring-配置类注入"><a href="#spring-配置类注入" class="headerlink" title="spring 配置类注入"></a>spring 配置类注入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>      <span class="comment">//声明该类为配置类</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)        <span class="comment">//指明配置文件位置  会自动去resouces下找到此文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myconfig</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverclass&#125;"</span>)       <span class="comment">//使用EL表达式获取到对应的值   会为属性自动注入对应的值</span></span><br><span class="line">     <span class="keyword">private</span> String driverClass;</span><br><span class="line">     <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">     <span class="keyword">private</span> String url;</span><br><span class="line">     <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">     <span class="keyword">private</span> String username;</span><br><span class="line">     <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">     <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line"></span><br><span class="line">        druidDataSource.setDriverClassName(driverClass);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值方式</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;some.key:my default value&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String stringWithDefaultValue;</span><br></pre></td></tr></table></figure>

<h1 id="nginx-负载均衡配置"><a href="#nginx-负载均衡配置" class="headerlink" title="nginx 负载均衡配置"></a>nginx 负载均衡配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com       weight&#x3D;5;</span><br><span class="line">    server backend2.example.com:8080;</span><br><span class="line">    server unix:&#x2F;tmp&#x2F;backend3;</span><br><span class="line"></span><br><span class="line">    server backup1.example.com:8080   backup;</span><br><span class="line">    server backup2.example.com:8080   backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="js代码输出结果"><a href="#js代码输出结果" class="headerlink" title="js代码输出结果"></a>js代码输出结果</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baidu</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“JavaScript 中，函数及变量的声明都将被提升到函数的最顶部”，注意，“只有声明的变量会提升，初始化的值却不会。”</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baidu</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> foo;  <span class="comment">//提升到函数最顶部</span></span><br><span class="line">     <span class="built_in">console</span>.log(foo);  <span class="comment">//输出未定义</span></span><br><span class="line">     foo =<span class="number">2</span>; </span><br><span class="line">     <span class="built_in">console</span>.log(foo); <span class="comment">//输出2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常识-有关SessionFactory"><a href="#常识-有关SessionFactory" class="headerlink" title="常识 有关SessionFactory"></a>常识 有关SessionFactory</h1><p>一个SessionFactory对象对应一个数据库存储源<br>SessionFactory是重量级的对象，不应该随意创建，如果系统中只有一个数据库存储源，只需要创建一个<br>它是线程安全得</p>
<h1 id="mysql主从复制配置"><a href="#mysql主从复制配置" class="headerlink" title="mysql主从复制配置"></a>mysql主从复制配置</h1><h1 id="redis-和mysql区别"><a href="#redis-和mysql区别" class="headerlink" title="redis 和mysql区别"></a>redis 和mysql区别</h1><ul>
<li>mysql是经典的关系型数据库，而redis是非关系型数据库。</li>
<li>这两者的主要差异在于查询，redis只能用key去获取value，不支持sql语句来进行查询。而mysql则只能通过sql语句来进行查询，不能直接通过key来获取value。</li>
<li>因为redis的数据读取过程的时间复杂度是O(1)，也就是说和数据量无关。再加上数据保存在内存，所以读取速度在理论上已经达到了上限。而mysql的查询则是通过扫描表来进行，读取的速度取决于数据量，以及是否有合适的索引。<br><a href="https://www.zhihu.com/question/61566731/answer/189296602" target="_blank" rel="noopener">原文链接</a></li>
</ul>
<h1 id="redis知识点"><a href="#redis知识点" class="headerlink" title="redis知识点"></a>redis知识点</h1><p><a href="https://www.lagou.com/lgeduarticle/82159.html" target="_blank" rel="noopener">原文参见</a></p>
<h1 id="java字符串拼接"><a href="#java字符串拼接" class="headerlink" title="java字符串拼接"></a>java字符串拼接</h1><p><a href="https://www.cnblogs.com/lujiahua/p/11408689.html" target="_blank" rel="noopener">原文参见</a></p>
<h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><p>选课数超过三门学生的sid，课程数，平均成绩，<br>select sid,count(cid),avg(score) from sc where sid in(<br>    select sid from sc group by sid having count(cid) &gt;=3) GROUP BY sid ;</p>
<p>找出没有选修过李四老师讲授课程的所有学生姓名<br>select sid,sname from student where sid not in (<br>select sc.sid from sc,course c ,teacher t where<br>sc.cid=c.cid and t.tid=c.tid and tname = ‘李四’);</p>
<p>列出两门及两门以上不及格同学的姓名和平均成绩<br>select sname,avg(score) from sc,student s where sc.sid = s.sid and sc.score &lt;60 group by sc.sid having count(cid)&gt;=2</p>
<h1 id="题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。"><a href="#题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。" class="headerlink" title="题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。"></a>题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。</h1><p>解题思路: 一直遍历这个数组，每隔2个删除一个元素，直到只剩下一个元素 如果遇到了数组的结尾，那么就跳转到开头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        list.add(<span class="number">11</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 第二种思路 一直遍历这个数组，每隔2个删除一个元素，直到只剩下一个元素 如果遇到了数组的结尾，那么就跳转到开头</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果到了末尾，则重新回到开头</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= list.size()) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">2</span> &gt;= list.size()) &#123;</span><br><span class="line">                i = -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除元素</span></span><br><span class="line">            i = i + <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">"删除"</span> + list.get(i) + <span class="string">"号"</span>);</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"最后剩下的人是"</span> + list.get(<span class="number">0</span>) + <span class="string">"号"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p>不可变对象(Immutable Object)：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。<br>不可变类特点：<br>将类声明为final，所以它不能被继承；</p>
<p>将所有的成员声明为私有的，这样就不允许直接访问这些成员；</p>
<p>对变量不要提供setter方法；</p>
<p>将所有可变的成员声明为final，这样只能对它们赋值一次；</p>
<p>通过构造器初始化所有成员，进行深拷贝（deep copy）；</p>
<p>在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝；</p>
<h1 id="面试题-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#面试题-当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="面试题:当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>面试题:当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h1><p>答:是值传递。Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象,对象的内容可以在被调用的方法中改变，但对象的引用(不是引用的副本)是永远不会改变的。</p>
<h1 id="union-和-union-all-区别"><a href="#union-和-union-all-区别" class="headerlink" title="union 和 union all 区别"></a>union 和 union all 区别</h1><p>union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；<br>union All：对两个结果集进行并集操作，包括重复行，不进行排序；</p>
<h1 id="oracle有几种临时表，有什么区别"><a href="#oracle有几种临时表，有什么区别" class="headerlink" title="oracle有几种临时表，有什么区别"></a>oracle有几种临时表，有什么区别</h1><ul>
<li>会话级临时表采用 on commit preserve rows ;而事务级则采用 on commit delete rows ;</li>
<li>用法上，会话级别只有当会话结束临时表中的数据才会被截断，而且事务级临时表则不管是 commit 、 rollback 或者是会话结束，临时表中的数据都将被截断</li>
</ul>
<h1 id="压缩字符串-aaabbbc-gt-a3b3c"><a href="#压缩字符串-aaabbbc-gt-a3b3c" class="headerlink" title="压缩字符串 aaabbbc =&gt; a3b3c"></a>压缩字符串 aaabbbc =&gt; a3b3c</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">compressStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">int</span> sum =<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">char</span> c1 = str.charAt(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">          <span class="keyword">char</span> c2 = str.charAt(i);</span><br><span class="line">          <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">              sum ++;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (sum &gt;<span class="number">1</span>)&#123;</span><br><span class="line">              sb.append(c1).append(sum);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sb.append(c1);</span><br><span class="line">          &#125;</span><br><span class="line">          c1 =c2;</span><br><span class="line">          sum =<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sum &gt;<span class="number">1</span>)&#123;</span><br><span class="line">          sb.append(c1).append(sum);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sb.append(c1);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="查询用户最新的记录"><a href="#查询用户最新的记录" class="headerlink" title="查询用户最新的记录"></a>查询用户最新的记录</h1><p>select id,time from user_a gorup by id order by time desc;</p>
<h1 id="springMVC中controller式单例的-如何保证并发的安全？"><a href="#springMVC中controller式单例的-如何保证并发的安全？" class="headerlink" title="springMVC中controller式单例的,如何保证并发的安全？"></a>springMVC中controller式单例的,如何保证并发的安全？</h1><p>1、不要在controller中定义成员变量。定义为静态的变量<br>2、万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式。<br>3、在Controller中使用ThreadLocal变量</p>
<h1 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h1><p>可扩展性:在增加业务功能时，单一应用架构需要在原先架构的代码基础上做比较大的调整，而微服务架构只需要增加新的微服务节点，并调整与之有关联的微服务节点即可。在增加业务响应能力时，单一架构需要进行整体扩容，而微服务架构仅需要扩容响应能力不足的微服务节点。</p>
<p>容错性:在系统发生故障时，单一应用架构需要进行整个系统的修复，涉及到代码的变更和应用的启停，而微服务架构仅仅需要针对有问题的服务进行代码的变更和服务的启停。其他服务可通过重试、熔断等机制实现应用层面的容错。</p>
<p>技术选型灵活:微服务架构下，每个微服务节点可以根据完成需求功能的不同，自由选择最适合的技术栈，即使对单一的微服务节点进行重构，成本也非常低。</p>
<p>开发运维效率更高:每个微服务节点都是一个单一进程，都专注于单一功能，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模团队或者个人完全掌控，易于保持高可维护性和开发效率。</p>
<h1 id="kafka概念以及如何保证kafka消息不丢"><a href="#kafka概念以及如何保证kafka消息不丢" class="headerlink" title="kafka概念以及如何保证kafka消息不丢"></a>kafka概念以及如何保证kafka消息不丢</h1><ul>
<li><p>Kafka是分布式发布-订阅消息系统，它最初是由LinkedIn公司开发的，之后成为Apache项目的一部分，Kafka是一个分布式，可划分的，冗余备份的持久性的日志服务，它主要用于处理流式数据。</p>
</li>
<li><p>生产者可靠性：</p>
<ul>
<li>通过配置参数 request.required.acks=-1，所有ISR列表中的所有副本同步数据完成后才leader向生产者发送成功消息；</li>
<li>开启副本数 min.insync.replicas&gt;=2</li>
<li>开启幂等性 enable.idempotence=true</li>
<li>开启不允许非isr副本选举为 leader,unclean.leader.election.enable=false</li>
</ul>
</li>
<li><p>消费者可靠性：</p>
<ul>
<li>enable.auto.commit=false 关闭自动提交offset</li>
</ul>
</li>
</ul>
<h1 id="tree、b-tree、b-tree数据结构"><a href="#tree、b-tree、b-tree数据结构" class="headerlink" title="tree、b tree、b+tree数据结构"></a>tree、b tree、b+tree数据结构</h1><p><a href="https://www.cnblogs.com/fengff/p/10216184.html" target="_blank" rel="noopener">原文参见</a></p>
<h1 id="jstl-遍历list"><a href="#jstl-遍历list" class="headerlink" title="jstl 遍历list"></a>jstl 遍历list</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach var&#x3D;&quot;userList&quot;  items&#x3D;&quot;$&#123; list &#125;&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;userList.id&#125;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;userList.username &#125;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;userList.password &#125;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;userList.birthday &#125;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;userList.salary &#125;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;%-- 也可以&lt;td&gt;&lt;c:out value&#x3D;&quot;$&#123;userList.id&#125;&quot;&#x2F;&gt;&lt;&#x2F;td&gt; --%&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;c:forEach&gt;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/JAVA/" data-id="ckautpojr000e94rh6vqsatiu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/21/OrientedObject/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          OrientedObject
        
      </div>
    </a>
  
  
    <a href="/2020/04/19/sql_optimize/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">sql_optimize</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/31/spring%E6%8F%AD%E5%AF%86/">spring揭密</a>
          </li>
        
          <li>
            <a href="/2020/05/15/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E6%80%BB%E7%BB%93/">并发编程艺术总结</a>
          </li>
        
          <li>
            <a href="/2020/05/14/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">git常用命令</a>
          </li>
        
          <li>
            <a href="/2020/05/09/thread/">thread</a>
          </li>
        
          <li>
            <a href="/2020/05/09/netcompile/">netcompile</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>